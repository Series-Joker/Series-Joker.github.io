<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>李航&lt;统计学&gt;学习笔记</title>
      <link href="/2020/05/20/li-hang-tong-ji-xue-xue-xi-bi-ji/"/>
      <url>/2020/05/20/li-hang-tong-ji-xue-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p>1，统计学习与机器学习是关于计算机基于数据结构构建概率统计模型并运用模型对数据进行分析和预测的一门学科。统计学包括监督学习，无监督学习和强化学习。</p><p>2，统计学习方法三要素——模型，策略，算法。</p><p>3，监督学习概括如下：从给定有限的训练 数据出发，假设数据是独立分布的，而且假设模型属于某个假设空间，应用某一评价准则，从假设空间中选取一个最优的模型，是它对已给训练 数据及未知测试数据在给定评价标准意义下有最准确的预测。</p><p>4，统计学习中，进行模型选择或者说提高学习的泛化能力是一个重要问题。如果只考虑减少训练误差，就可能产生过拟合现象。模型选择的方法有正则化和交叉验证。学习泛化能力的分析是统计学习理论研究的重要课题。</p><p>5，分类问题，标注问题和回归问题都是监督学习的重要问题。第一章介绍的统计学习方法包括感知机，k近邻，朴素贝叶斯，决策树，逻辑回归与最大熵模型，支持向量机，提升方法，EM算法，隐马尔科夫模型和条件随机场。这些方法是主要的分类，标注以及回归方法。他们又可以归类为生成方法与判别方法。</p><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>1，说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学三要素</p><p>1.1三要素分别是模型，策略，算法</p><p>模型，即定义在求值为0和1的随机变量上的概率分布</p><p>策略：极大似然估计与贝叶斯估计的策略都是损失函数，只不过贝叶斯使用的是结构化风险最小化。</p><p>算法：极大似然估计所使用的算法是求经验风险函数的极小值，贝叶斯使用求取参数经验的后验分布。然后计算其期望。定义为A取值为o或1的随机变量，并设A=1的概率是θ，</p><p>$$<br><em>P</em>(<em>A</em>=1)=<em>θ</em>,<em>P</em>(<em>A</em>=0)=1−<em>θ</em><br>$$<br>独立抽取n个同分布的随机变量A1,A2,……An。使用极大似然估计即求取以下经验风险函数的极值点：<br>$$<br><em>L</em>(<em>P</em>)=−<em>i</em>=1∑<em>n</em>log<em>P</em>(<em>A**i</em>)=−<em>k</em>log<em>θ</em>−(<em>n</em>−<em>k</em>)log(1−<em>θ</em>)<br>$$<br>即求θ，使得：<br>$$<br>∂<em>P</em>∂<em>L</em>(<em>P</em>)∣∣∣∣<em>θ</em>′=−<em>θ</em>′<em>k</em>−1−<em>θ</em>′<em>n</em>−<em>k</em>=0<br>$$<br>即得θ\thetaθ的估计值为θ=k/n</p><p>如果使用贝叶斯估计，则将A=1A=1A=1的概率θ\thetaθ也看做是一个随机变量，假设其先验分布为均匀分布，即：<br>$$<br><em>f</em>(<em>θ</em>)=1<br>$$<br>那么根据贝叶斯定理，其后验分布为：</p><p><em>f</em>(<em>θ</em>∣<em>A</em>1,…,<em>A**n</em>)=∫<em>f</em>(<em>A</em>1,…,<em>A**n</em>)⋅<em>f</em>(<em>θ</em>)d<em>θ**f</em>(<em>A</em>1,…,<em>A*<em>n</em>∣*θ</em>)⋅<em>f</em>(<em>θ</em>)</p><p>上式中分母与θ无关，所以可忽略，即：</p><p><em>f</em>(<em>θ</em>∣<em>A</em>1,…,<em>A**n</em>)∝<em>θ**k</em>(1−<em>θ</em>)(<em>n</em>−<em>k</em>)=<em>θ**k</em>+1−1(1−<em>θ</em>)<em>n</em>−<em>k</em>+1−1此时，如果想要最大化后验概率，即求θ使得f(<em>θ</em>|A1,…..An)最大，只需求解<em>θ</em>最终所求结果与最大似然估计法一样。</p><p>注意，我们还可以求解在均方（期望）意义下θ\thetaθ的值，事实上，参数为a,ba, ba,b的Beta分布的概率密度函数如下</p><p><em>f</em>(<em>p</em>;<em>a</em>,<em>b</em>)=Γ(<em>a</em>)Γ(<em>b</em>)Γ(<em>a</em>+<em>b</em>)<em>p*<em>a</em>−1(1−*p</em>)<em>b</em>−1</p><p>因此可以看出，θ\thetaθ的后验分布服从参数为k+1k+1k+1和n−k+1n-k+1n−k+1的Beta分布，即：</p><p><em>f</em>(<em>θ</em>∣<em>A</em>1,…,<em>A**n</em>)=Γ(<em>k</em>+1)Γ(<em>n</em>−<em>k</em>+1)Γ(<em>n</em>+2)<em>θ**k</em>+1−1(1−<em>θ</em>)<em>n</em>−<em>k</em>+1−1</p><p>因此，上式的期望（即θ\thetaθ的估计值）为：</p><p><em>E</em>(<em>θ</em>)=k+1/n+2</p><p>1.2证明：模型是条件概率分布，当损失函数是对数损失时，经验风险最小化等价于极大似然估计。</p><p>损失函数：度量模型一次预测的好坏</p><p>风险函数：度量平均意义下的模型预测好坏</p><p>首先需要理解几个概念，条件概率分布，对数损失，经验风险和极大似然估计</p><p>模型是条件概率分布，说明预测值：</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/2020/05/15/fen-zhi-fa/"/>
      <url>/2020/05/15/fen-zhi-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>分治算法，根据字面意思解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><h4 id="算法策略"><a href="#算法策略" class="headerlink" title="算法策略"></a>算法策略</h4><p>分治策略：对于一个规模为 n 的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。<br>  在平时日常生活中，分治思想也是随处可见的。例如：当我们打牌时，在进行洗牌时，若牌的数目较多，一个人洗不过来，则会将牌进行分堆，单独洗一小堆牌是相对容易的，每一堆牌都洗完之后再放到一起，则完成洗牌过程。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>（1）该问题的规模缩小到一定的程度就可以容易地解决。<br>（2）该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。<br>（3）利用该问题分解出的子问题的解可以合并为该问题的解。<br>（4）该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4><p>（1）分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题。<br>（2）求解：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题。<br>（3）合并：将各个子问题的解合并为原问题的解。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><pre><code> Divide-and-Conquer(P)    if |P| ≤ n0        then return(ADHOC(P))    将P分解为较小的子问题 P1 ,P2 ,...,Pk        for i←1 to k            do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi        T ← MERGE(y1,y2,...,yk) △ 合并子问题    return(T)</code></pre><p>其中，|P| 表示问题 P 的规模，n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。ADHOC(P) 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过n0 时直接用算法 ADHOC(P) 求解。算法 MERGE(y1,y2,…,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,…,Pk 的相应的解 y1 , y2 ,…, yk 合并为 P 的解。</p><h4 id="典型案例"><a href="#典型案例" class="headerlink" title="典型案例"></a>典型案例</h4><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><p>二分查找是典型的分治算法的应用。需要注意的是，二分查找的前提是查找的数列是有序的。</p><p><strong>算法流程：</strong><br>  （1）选择一个标志 i 将集合分为二个子集合。<br>  （2）判断标志 L(i) 是否能与要查找的值 des 相等，相等则直接返回。<br>  （3）否则判断 L(i) 与 des 的大小。<br>  （4）基于判断的结果决定下步是向左查找还是向右查找。<br>  （5）递归继续上面的步骤。</p><p>  通过二分查找的流程可以看出，二分查找是将原有序数列划分为左右两个子序列，然后在对两个子序列中的其中一个在进行划分，直至查找成功。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code>class Solution(object):    def searchInsert(self, nums, target):        """        :type nums: List[int]        :type target: int        :rtype: int        """        size = len(nums)        first = 0        last = size - 1        while first &lt;= last:            mid = (first + last) / 2            if nums[mid] == target:                return mid            elif nums[mid] &gt; target:                last = mid - 1            elif nums[mid] &lt; target:                first = mid + 1        return first</code></pre><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。即先划分为两个部分，最后进行合并。</p><pre><code>def mergesort(seq):    mid = len(seq) // 2    if len(seq) &lt;= 1:        return seq    lft = mergesort(seq[:mid])    rgt = mergesort(seq[mid:])    res = []    while lft and rgt:        if lft[-1] &gt;= rgt[-1]:            res.append(lft.pop())        else:            res.append(rgt.pop())    res.reverse()    # 返回合并排序后的序列    return lft + rgt + res</code></pre><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>快速排序的基本思想：当前待排序的无序区为 A[low..high] ，利用分治法可将快速排序的基本思想描述为：<br>（1）分解：<br>  在A[low..high]中任选一个记录作为基准(pivot)，以此基准将当前无序区划分为左、右两个较小的子区间R[low..pivotpos-1) 和 R[pivotpos+1..high] ，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为pivot)的关键字 pivot.key，右边的子区间中所有记录的关键字均大于等于pivot.key，而基准记录pivot则位于正确的位置( pivotpos )上，它无须参加后续的排序。</p><p>（2）求解：<br>  通过递归调用快速排序对左、右子区间R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。<br>（3）合并：<br>  因为当”求解”步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，”组合”步骤无须做什么，可看作是空操作。</p><pre><code>def partition(seq):    pi,seq = seq[0],seq[1:]    lo = [x for x in seq if x &lt;= pi]    hi = [x for x in seq if x &gt; pi]    return lo,pi,hidef quicksort(seq):    if len(seq) &lt;= 1:        return seq    lo,pi,hi = partition(seq)    return quicksort(lo)+[pi]+quicksort(hi)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划你不得不熟悉的算法</title>
      <link href="/2020/05/15/dong-tai-gui-hua/"/>
      <url>/2020/05/15/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><p>用一句话解释动态规划就是 “<strong>记住你之前做过的事</strong>”，如果更准确些，其实是 “<strong>记住你之前得到的答案</strong>”。</p><p>我举个大家工作中经常遇到的例子。</p><p>在软件开发中，大家经常会遇到一些系统配置的问题，配置不对，系统就会报错，这个时候一般都会去 Google 或者是查阅相关的文档，花了一定的时间将配置修改好。</p><p>过了一段时间，去到另一个系统，遇到类似的问题，这个时候已经记不清之前修改过的配置文件长什么样，这个时候有两种方案，一种方案还是去 Google 或者查阅文档，另一种方案是借鉴之前修改过的配置，第一种做法其实是万金油，因为你遇到的任何问题其实都可以去 Google，去查阅相关文件找答案，但是这会花费一定的时间，相比之下，第二种方案肯定会更加地节约时间，但是这个方案是有条件的，条件如下：</p><ul><li>之前的问题和当前的问题有着关联性，换句话说，之前问题得到的答案可以帮助解决当前问题</li><li>需要记录之前问题的答案</li></ul><p>当然在这个例子中，可以看到的是，上面这两个条件均满足，大可去到之前配置过的文件中，将配置拷贝过来，然后做些细微的调整即可解决当前问题，节约了大量的时间。</p><p>不知道你是否从这些描述中发现，对于一个动态规划问题，我们只需要从两个方面考虑，那就是 <strong>找出问题之间的联系</strong>，以及 <strong>记录答案</strong>，这里的难点其实是找出问题之间的联系，记录答案只是顺带的事情，利用一些简单的数据结构就可以做到。</p><h2 id="思考动态规划问题的四个步骤"><a href="#思考动态规划问题的四个步骤" class="headerlink" title="思考动态规划问题的四个步骤"></a>思考动态规划问题的四个步骤</h2><p>一般解决动态规划问题，分为四个步骤，分别是</p><ul><li>问题拆解，找到问题之间的具体联系</li><li>状态定义</li><li>递推方程推导</li><li>实现</li></ul><p>这里面的重点其实是前两个，如果前两个步骤顺利完成，后面的递推方程推导和代码实现会变得非常简单。</p><p>这里还是拿 Quora 上面的例子来讲解，“1+1+1+1+1+1+1+1” 得出答案是 8，那么如何快速计算 “1+ 1+1+1+1+1+1+1+1”，我们首先可以对这个大的问题进行拆解，这里我说的大问题是 9 个 1 相加，这个问题可以拆解成 1 + “8 个 1 相加的答案”，8 个 1 相加继续拆，可以拆解成 1 + “7 个 1 相加的答案”，… 1 + “0 个 1 相加的答案”，到这里，<strong>第一个步骤</strong> 已经完成。</p><p><strong>状态定义</strong> 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 <code>后一个问题的答案 = 前一个问题的答案 + 1</code>，这里，状态的每次变化就是 +1。</p><p>定义好了状态，递推方程就变得非常简单，就是 <code>dp[i] = dp[i - 1] + 1</code>，这里的 <code>dp[i]</code> 记录的是当前问题的答案，也就是当前的状态，<code>dp[i - 1]</code> 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 +1 来实现状态的变更。</p><p>最后一步就是实现了，有了状态表示和递推方程，实现这一步上需要重点考虑的其实是初始化，就是用什么样的数据结构，根据问题的要求需要做那些初始值的设定。</p><h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h5><h6 id="题目描述假设你正在爬楼梯。需要-n-阶你才能到达楼顶。"><a href="#题目描述假设你正在爬楼梯。需要-n-阶你才能到达楼顶。" class="headerlink" title="题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。"></a>题目描述假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</h6><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</code></pre><p><strong>示例 2：</strong></p><pre><code>输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><h5 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h5><p><strong>爬楼梯，可以爬一步也可以爬两步，问有多少种不同的方式到达终点，我们按照上面提到的四个步骤进行分析：</strong></p><ul><li><p><strong>问题拆解</strong>：</p><p>我们到达第 n 个楼梯可以从第 n - 1 个楼梯和第 n - 2 个楼梯到达，因此第 n 个问题可以拆解成第 n - 1 个问题和第 n - 2 个问题，第 n - 1 个问题和第 n - 2 个问题又可以继续往下拆，直到第 0 个问题，也就是第 0 个楼梯 (起点)</p></li><li><p><strong>状态定义</strong></p><p>“问题拆解” 中已经提到了，第 n 个楼梯会和第 n - 1 和第 n - 2 个楼梯有关联，那么具体的联系是什么呢？你可以这样思考，第 n - 1 个问题里面的答案其实是从起点到达第 n - 1 个楼梯的路径总数，n - 2 同理，从第 n - 1 个楼梯可以到达第 n 个楼梯，从第 n - 2 也可以，并且路径没有重复，因此我们可以把第 i 个状态定义为 “<strong>从起点到达第 i 个楼梯的路径总数</strong>”，状态之间的联系其实是相加的关系。</p></li><li><p><strong>递推方程</strong></p><p>“状态定义” 中我们已经定义好了状态，也知道第 i 个状态可以由第 i - 1 个状态和第 i - 2 个状态通过相加得到，因此递推方程就出来了 <code>dp[i] = dp[i - 1] + dp[i - 2]</code></p></li><li><p><strong>实现</strong></p><p>你其实可以从递推方程看到，我们需要有一个初始值来方便我们计算，起始位置不需要移动 <code>dp[0] = 0</code>，第 1 层楼梯只能从起始位置到达，因此 <code>dp[1] = 1</code>，第 2 层楼梯可以从起始位置和第 1 层楼梯到达，因此 <code>dp[2] = 2</code>，有了这些初始值，后面就可以通过这几个初始值进行递推得到。</p><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5></li></ul><pre><code>class Solution(object):    def climbStairs(self, n):        dp = [0, 1]        for i in range(n):            dp[i%2] = dp[i%2] + dp[(i+1)%2]        return dp[(n+1)%2]</code></pre><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><pre><code>public int climbStairs(int n) {    if (n == 1) {        return 1;    }    int[] dp = new int[n + 1];  // 多开一位，考虑起始位置    dp[0] = 0; dp[1] = 1; dp[2] = 2;    for (int i = 3; i &lt;= n; ++i) {        dp[i] = dp[i - 1] + dp[i - 2];    }    return dp[n];}</code></pre><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><h5 id="题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。"><a href="#题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。" class="headerlink" title="题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。"></a>题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</h5><p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p><p><strong>例如，给定三角形：</strong></p><pre><code>[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]</code></pre><p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11）。</p><h5 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h5><ul><li><p>问题拆解：</p><p>这里的总问题是求出最小的路径和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯那道题目类似，<code>[i][j]</code> 位置的元素，经过这个元素的路径肯定也会经过 <code>[i - 1][j]</code> 或者 <code>[i - 1][j - 1]</code>，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。</p></li><li><p>状态定义</p><p>状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从<code>[i - 1][j]</code> 获得，每行当中的最后一个元素的路径只会从 <code>[i - 1][j - 1]</code> 获得，中间二者都可，这样不太好实现，因此这里考虑从下到上的方式，状态的定义就变成了 “<strong>最后一行元素到当前元素的最小路径和</strong>”，对于 <code>[0][0]</code> 这个元素来说，最后状态表示的就是我们的最终答案。</p></li><li><p>递推方程</p><p>“状态定义” 中我们已经定义好了状态，递推方程就出来了</p><pre><code>dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]</code></pre></li><li><p>实现</p><p>这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可</p><h5 id="Python参考代码"><a href="#Python参考代码" class="headerlink" title="Python参考代码"></a>Python参考代码</h5></li></ul><pre><code>def minimumTotal(self, triangle):    for i in range(len(triangle) - 1, 0, -1):        for j in range(i):            triangle[i - 1][j] += min(triangle[i][j], triangle[i][j + 1])    return triangle[0][0]</code></pre><h5 id="java参考代码"><a href="#java参考代码" class="headerlink" title="java参考代码"></a>java参考代码</h5><pre><code>public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) {    int n = triangle.size();    int[][] dp = new int[n][n];    List&lt;Integer&gt; lastRow = triangle.get(n - 1);    for (int i = 0; i &lt; n; ++i) {        dp[n - 1][i] = lastRow.get(i);    }    for (int i = n - 2; i &gt;= 0; --i) {        List&lt;Integer&gt; row = triangle.get(i);        for (int j = 0; j &lt; i + 1; ++j) {            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + row.get(j);        }    }    return dp[0][0];}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五分钟了解一下贪心算法</title>
      <link href="/2020/05/15/tan-xin-suan-fa/"/>
      <url>/2020/05/15/tan-xin-suan-fa/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>贪心的意思在于在作出选择时，每次都要选择对自身最为有利的结果，保证自身利益的最大化。贪心算法就是利用这种贪心思想而得出一种算法。</p><p>贪心算法作为五大算法之一，在数据结构中的应用十分广泛。例如：在求最小生成树的 Prim 算法中，挑选的顶点是候选边中权值最小的边的一个端点。在 Kruskal 算法中，每次选取权值最小的边加入集合。在构造霍夫曼树的过程中也是每次选择最小权值的节点构造二叉树。这种每次在执行子问题的求解时，总是选择当前最优的情形，恰好符合贪心的含义。</p><p>贪心算法可以简单描述为：大事化小，小事化了。对于一个较大的问题，通过找到与子问题的重叠，把复杂的问题划分为多个小问题。并且对于每个子问题的解进行选择，找出最优值，进行处理，再找出最优值，再处理。也就是说贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</p><p><strong>贪心算法在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，</strong>但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><pre><code>从问题的某一初始解出发    while (能朝给定总目标前进一步)         do            选择当前最优解作为可行解的一个解元素；    由所有解元素组合成问题的一个可行解。</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>例子就是我去前面leetcode里面的硬币问题</p><p>小明手中有 1，5，10，50，100 五种面额的纸币，每种纸币对应张数分别为 5，2，2，3，5 张。若小明需要支付 456 元，则需要多少张纸币？</p><h5 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h5><p>（1）<strong>建立数学模型</strong></p><p>设小明每次选择纸币面额为 Xi ，需要的纸币张数为 n 张，剩余待支付金额为 V ，则有：<br>$$<br>X1 + X2 + … + Xn = 456.<br>$$</p><p>（2）<strong>问题拆分为子问题</strong></p><p>小明选择纸币进行支付的过程，可以划分为n个子问题：即每个子问题对应为：<br>在未超过456的前提下，在剩余的纸币中选择一张纸币。</p><p>（3）<strong>制定贪心策略，求解子问题</strong></p><p>制定的贪心策略为：在允许的条件下选择面额最大的纸币。则整个求解过程如下：</p><ul><li><p>选取面值为 100 的纸币，则 X1 = 100, V = 456 – 100 = 356；</p></li><li><p>继续选取面值为 100 的纸币，则 X2 = 100, V = 356 – 100 = 256；</p></li><li><p>继续选取面值为 100 的纸币，则 X3 = 100, V = 256 – 100 = 156；</p></li><li><p>继续选取面值为 100 的纸币，则 X4 = 100, V = 156 – 100 = 56；</p></li><li><p>选取面值为 50 的纸币，则 X5 = 50, V = 56 – 50 = 6；</p></li><li><p>选取面值为 5 的纸币，则 X6 = 5, V = 6 – 5 = 1；</p></li><li><p>选取面值为 1 的纸币，则 X7 = 1, V = 1 – 1 = 0；求解结束</p><p>（4）<strong>将所有解元素合并为原问题的解</strong></p></li></ul><p>小明需要支付的纸币张数为 7 张，其中面值 100 元的 4 张，50 元 1 张，5 元 1 张，1 元 1 张。</p><pre><code>const int N = 5; int Count[N] = {5,2,2,3,5};//每一张纸币的数量 int Value[N] = {1,5,10,50,100};int solve(int money) {    int num = 0;    for(int i = N-1;i&gt;=0;i--) {        int c = min(money/Value[i],Count[i]);//每一个所需要的张数         money = money-c*Value[i];        num += c;//总张数     }    if(money&gt;0) num=-1;    return num;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学好数据结构与算法</title>
      <link href="/2020/05/15/dp2/"/>
      <url>/2020/05/15/dp2/</url>
      
        <content type="html"><![CDATA[<p>我画了一张图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。这里面有10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。<br>掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。</p><h4 id="知识脉络图"><a href="#知识脉络图" class="headerlink" title="知识脉络图"></a>知识脉络图</h4><p><img src="/1.jpg" alt="1"></p><p>我这MarkDown插入图片一致不显示，我不知道为什么，后面再研究一下</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP问题分类汇总</title>
      <link href="/2020/05/15/dp/"/>
      <url>/2020/05/15/dp/</url>
      
        <content type="html"><![CDATA[<h4 id="DP问题的分类"><a href="#DP问题的分类" class="headerlink" title="DP问题的分类"></a>DP问题的分类</h4><ol><li>线性DP；</li><li>区间DP；</li><li>背包DP；</li><li>树形DP；</li><li>状态压缩DP；</li><li>数位DP；</li><li>计数型DP；</li><li>递推型DP；</li><li>概率型DP；</li><li>博弈型DP；</li><li>记忆化搜索；</li></ol><h4 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h4><p>最经典单串：</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a> (LIS)</p><p>最经典双串：</p><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a> (LCS)</p><p><strong>经典问题：</strong></p><p><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></p><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></p><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></p><p><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">887. 鸡蛋掉落</a> (DP+二分)</p><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" target="_blank" rel="noopener">354. 俄罗斯套娃信封问题</a> (隐晦的LIS)</p><p><strong>打家劫舍系列: (打家劫舍3 是树形DP)</strong></p><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></p><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></p><p><strong>股票系列:</strong></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 最佳买卖股票时机含冷冻期</a></p><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></p><p><strong>字符串匹配系列</strong></p><p><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></p><p><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. 通配符匹配</a></p><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. 正则表达式匹配</a></p><h4 id="2-区间DP"><a href="#2-区间DP" class="headerlink" title="2. 区间DP"></a><strong>2. 区间DP</strong></h4><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></p><p><a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/" target="_blank" rel="noopener">730. 统计不同回文子字符串</a></p><p><a href="https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">1039. 多边形三角剖分的最低得分</a></p><p><a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">664. 奇怪的打印机</a></p><p><a href="https://leetcode-cn.com/problems/burst-balloons/" target="_blank" rel="noopener">312. 戳气球</a></p><h4 id="3-背包DP"><a href="#3-背包DP" class="headerlink" title="3. 背包DP"></a><strong>3. 背包DP</strong></h4><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a> (01背包-要求恰好取到背包容量)</p><p><a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a> (01背包-求方案数)</p><p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a> (完全背包)</p><p><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">518. 零钱兑换 II</a> (完全背包-求方案数)</p><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a> (二维费用背包)</p><h4 id="4-树形DP"><a href="#4-树形DP" class="headerlink" title="4. 树形DP"></a><strong>4. 树形DP</strong></h4><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></p><p><a href="https://leetcode-cn.com/problems/tree-diameter/" target="_blank" rel="noopener">1245. 树的直径</a> (<strong>邻接表上的树形DP</strong>)</p><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></p><p><a href="https://leetcode-cn.com/problems/largest-bst-subtree/" target="_blank" rel="noopener">333. 最大 BST 子树</a></p><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></p><h4 id="5-状态压缩DP"><a href="#5-状态压缩DP" class="headerlink" title="5. 状态压缩DP"></a><strong>5. 状态压缩DP</strong></h4><p><a href="https://leetcode-cn.com/problems/can-i-win/" target="_blank" rel="noopener">464. 我能赢吗</a></p><p><a href="https://leetcode-cn.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. 优美的排列</a></p><p><a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a></p><p><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">1349. 参加考试的最大学生数</a></p><h4 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="6. 数位DP"></a><strong>6. 数位DP</strong></h4><p><a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">233. 数字 1 的个数</a></p><p><a href="https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/" target="_blank" rel="noopener">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/" target="_blank" rel="noopener">1015. 可被 K 整除的最小整数</a></p><h4 id="7-计数型DP"><a href="#7-计数型DP" class="headerlink" title="7. 计数型DP"></a><strong>7. 计数型DP</strong></h4><p><strong>计数型DP都可以以组合数学的方法写出组合数，然后dp求组合数</strong></p><p><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></p><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></p><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a> (<strong>卡特兰数</strong>)</p><p><a href="https://leetcode-cn.com/problems/handshakes-that-dont-cross/" target="_blank" rel="noopener">1259. 不相交的握手</a> (<strong>卢卡斯定理</strong>求大组合数模质数)</p><h4 id="8-递推型DP"><a href="#8-递推型DP" class="headerlink" title="8. 递推型DP"></a><strong>8. 递推型DP</strong></h4><p><strong>所有线性递推关系都可以用矩阵快速幂做，可以O(logN)，最典型是斐波那契数列</strong></p><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></p><p><a href="https://leetcode-cn.com/problems/knight-dialer/" target="_blank" rel="noopener">935. 骑士拨号器</a></p><p><a href="https://leetcode-cn.com/problems/prison-cells-after-n-days/" target="_blank" rel="noopener">957. N 天后的牢房</a></p><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">1137. 第 N 个泰波那契数</a></p><h4 id="9-概率型DP"><a href="#9-概率型DP" class="headerlink" title="9. 概率型DP"></a><strong>9. 概率型DP</strong></h4><p><strong>求概率，求数学期望</strong></p><p><a href="https://leetcode-cn.com/problems/soup-servings/" target="_blank" rel="noopener">808. 分汤</a></p><p><a href="https://leetcode-cn.com/problems/new-21-game/" target="_blank" rel="noopener">837. 新21点</a></p><h4 id="10-博弈型DP"><a href="#10-博弈型DP" class="headerlink" title="10. 博弈型DP"></a><strong>10. 博弈型DP</strong></h4><p><strong>策梅洛定理，SG定理，minimax</strong></p><h6 id="翻转游戏"><a href="#翻转游戏" class="headerlink" title="翻转游戏"></a>翻转游戏</h6><p><a href="https://leetcode-cn.com/problems/flip-game/" target="_blank" rel="noopener">293. 翻转游戏</a></p><p><a href="https://leetcode-cn.com/problems/flip-game-ii/" target="_blank" rel="noopener">294. 翻转游戏 II</a></p><h6 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h6><p><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a></p><h6 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a>石子游戏</h6><p><a href="https://leetcode-cn.com/problems/stone-game/" target="_blank" rel="noopener">877. 石子游戏</a></p><p><a href="https://leetcode-cn.com/problems/stone-game-ii/" target="_blank" rel="noopener">1140. 石子游戏 II</a></p><h6 id="井字游戏"><a href="#井字游戏" class="headerlink" title="井字游戏"></a>井字游戏</h6><p><a href="https://leetcode-cn.com/problems/design-tic-tac-toe/" target="_blank" rel="noopener">348. 判定井字棋胜负</a></p><p><a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/" target="_blank" rel="noopener">794. 有效的井字游戏</a></p><p><a href="https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/" target="_blank" rel="noopener">1275. 找出井字棋的获胜者</a></p><h4 id="11-记忆化搜索"><a href="#11-记忆化搜索" class="headerlink" title="11. 记忆化搜索"></a><strong>11. 记忆化搜索</strong></h4><p><strong>本质是 dfs + 记忆化，用在状态的转移方向不确定的情况</strong></p><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></p><p><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">576. 出界的路径数</a></p><p>​                                                                    ———————————————-转自知乎</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode10/"/>
      <url>/2020/05/13/leetcode10/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p><p>一看到题目我就想到斐波那契数列，首先想到递归或动态规划或贪心</p><p><strong>示例1:</strong></p><pre><code>输入: n = 5 输出：2 解释: 有两种方式可以凑成总金额:5=55=1+1+1+1+1</code></pre><p><strong>示例2:</strong></p><pre><code> 输入: n = 10 输出：4 解释: 有四种方式可以凑成总金额:10=1010=5+510=5+1+1+1+1+110=1+1+1+1+1+1+1+1+1+1</code></pre><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><pre class="line-numbers language-python3"><code class="language-python3"># dp[i][j] 使用前i种硬币计算j分的表示法种数 令coins=[25, 10, 5, 1]# dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]# j >= k*coins[i]# dp[i][j-coins[i]] = dp[i-1][j-coins[i]] + dp[i-1][j-2*coins[i]] + ... dp[i-1][j-k*coins[i]]# dp[i][j] - dp[i][j-coins[i]] = dp[i-1][j]# dp[i][j] = dp[i][j-coins[i]] + dp[i-1][j]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>class Solution:    def waysToChange(self, n: int) -&gt; int:        coins = [25, 10, 5, 1]        # 注意dp的初始化，表示没有硬币情况下凑金额0-n分        dp = [0] * (n+1)        dp[0] = 1  # 没有硬币凑0分为1种方式        for i in range(len(coins)):            for j in range(coins[i], n+1):                dp[j] += dp[j-coins[i]]        return dp[-1] % 1000000007</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode9/"/>
      <url>/2020/05/13/leetcode9/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p><pre><code>'.' 匹配任意单个字符'*' 匹配零个或多个前面的那一个元素</code></pre><p><strong>示例 1:</strong></p><pre><code>输入:s = "aa"p = "a"输出: false解释: "a" 无法匹配 "aa" 整个字符串。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:s = "aa"p = "a*"输出: true解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regular-expression-matching著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入:s = "ab"p = ".*"输出: true解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。</code></pre><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>这个题投机取巧了，用了re正则匹配</p><pre><code>import reclass Solution:    def isMatch(self, s: str, p: str) -&gt; bool:        m = re.match(p,s)        if m!=None:            if m.group()==s:                return True            else:                return False        else:            return False</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode8/"/>
      <url>/2020/05/13/leetcode8/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p>给定一个整数数组 A，返回 A 中最长等差子序列的长度。</p><p>回想一下，A 的子序列是列表 A[i_1], A[i_2], …, A[i_k] 其中 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1。并且如果 B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1) 的值都相同，那么序列 B 是等差的。</p><p><strong>示例 1：</strong></p><pre><code>输入：[3,6,9,12]输出：4解释： 整个数组是公差为 3 的等差数列。</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[9,4,7,2,10]输出：3解释：最长的等差子序列是 [4,7,10]。</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：[20,1,15,3,10,5,8]输出：4解释：最长的等差子序列是 [20,15,10,5]。</code></pre><h4 id="Python解法一"><a href="#Python解法一" class="headerlink" title="Python解法一"></a>Python解法一</h4><pre><code>class Solution:    '''    动态规划思路：以每个元素作为等差数列终点，计算出该数列长度，选择出最大值返回即可。    在每个位置上，以字典结构保存该位置元素与前面每个位置上元素的差值，与对应该差值的数列长度。    '''    def longestArithSeqLength(self, A):        n = len(A)        max_len = 2        # dp[i]: A[i]表示以A[i]为等差数列终点        # dp[i] = {}, {}的key为A[i]为终点的等差数列的差值diff,value表示该等差数列的长度        dp = [{} for _ in range(n)]        # 注意双重循环的start和end, i为被减数的索引，j为减数的索引，j&lt;i        for i in range(1, n):            for j in range(i):                k = A[i] - A[j]         # 差值 = 后值 - 前值                # dp[j].get(k, 1)：字典dp[j]如果存在key=k,返回对应value，否则返回默认值1                m = dp[j].get(k, 1) + 1                dp[i][k] = m            max_len = max(max_len, max(dp[i].values()))        return max_len</code></pre><h4 id="Python解法二"><a href="#Python解法二" class="headerlink" title="Python解法二"></a>Python解法二</h4><pre><code>from collections import defaultdictclass Solution2:    def longestArithSeqLength(self, A):        n = len(A)        max_length = 2        # 建立字典储存A的信息，key是A的数值，val是这个数值的index的列表        mapping = defaultdict(list)        for i, val in enumerate(A):            mapping[val].append(i)        # 两层遍历：对于每个i，j看以A[i],A[j]为前两项的等差数列有几项        # 关注点：指向j的指针的位置, 下一个等差数列值需要在当前值的index以后的列表中查找        for i in range(0, n):            for j in range(i + 1, n):                length = 2                diff = A[j] - A[i]                      # 差值 = 后 - 前                while True:                    next_val = A[j] + diff              # next value                    if next_val not in mapping.keys():  # 查找 next_val 是否在 j 之后的索引对应的列表中                        break                    for_tag = False                     # 标示 是否在mapping[next_val]的索引列表中找到index&gt;j: true 找到                    for index in mapping[next_val]:     # 在列表中，则遍历mapping，找到大于j的索引，更新j为该索引                        if index &gt; j:                            j = index                   # 更新索引后退出该层循环，继续 while loop                            length += 1                            max_length = max(max_length, length)                            for_tag = True                            break                    if not for_tag:                     # 找到index&gt;j，继续 while loop,否则退出while                        break        return max_length</code></pre><h4 id="java-动态规划"><a href="#java-动态规划" class="headerlink" title="java 动态规划"></a>java 动态规划</h4><pre><code>class Solution {    public int longestArithSeqLength(int[] A) {        HashMap&lt;Integer,Integer&gt;[] dp = new HashMap[A.length];        for (int i = 0; i &lt; dp.length; i++) {            dp[i]=new HashMap&lt;&gt;();        }        int res=1;        for (int i = 1; i &lt; A.length; i++) {            for (int j = 0; j &lt;i ; j++) {                int diff = A[i] - A[j];                if (!dp[j].containsKey(diff)) {                    dp[i].put(diff,2);                }else {                    dp[i].put(diff,dp[j].get(diff)+1);                }                res=Math.max(res,dp[i].get(diff));            }        }        return res;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode7/"/>
      <url>/2020/05/13/leetcode7/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><pre><code>给出一个字符串，一个右偏移量和一个左偏移量，根据给出的偏移量循环移动字符串</code></pre><pre><code>输入： str='abcd',left = 3,right = 1输出： ‘cdab</code></pre><pre><code>def fun1(self,s,left,right):    offset = left - right    offset %= len(s)    result = s[offset: ] + s[ :offset]    return result</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode3/"/>
      <url>/2020/05/13/leetcode3/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><pre><code>由于只包含字符的字符串'(', ')'，'{'，'}'，'['和']'，确定输入字符串是有效的。括号必须关闭以正确的顺序，"()"并且"()[]{}"都是有效的，但"(]"并"([)]"没有。</code></pre><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><pre><code>class Solution:    def fun(self,s):        stack, pair = [], {"]" : "[", ")":"(", "}":"{"}        for i in s:            if i in "([{" : stack += i            elif:                stack and stack[-1] == pair[c]: stack.pop()            else:                return False        return -1</code></pre><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><pre><code>def fun2(self,k,n):    return ".join(map(str,range(n+1))).fun2(str(k))"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode2/"/>
      <url>/2020/05/13/leetcode2/</url>
      
        <content type="html"><![CDATA[<p>题目要求：</p><pre><code>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数</code></pre><p><strong>示例 1:</strong></p><pre><code>输入: [10,2]输出: 210</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [3,30,34,5,9]输出: 9534330</code></pre><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><pre><code>class Solution:    def sort(self, x, y):        left, right = x + y, y + x        return 1 if left &gt; right else -1    def largestNumber(self, nums):        if not nums:            return 0        if sum(nums) == 0:            return 0        str_list = [str(n) for n in nums]        str_list.sort(self.sort, reverse=True)</code></pre><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><pre><code>class Solution1:    def largestNumber(self, nums: List[int]) -&gt; str:        s = ''        for i in range(len(nums) - 1):            for j in range(i + 1, len(nums)):                if int(str(nums[i]) + str(nums[j])) &lt; int(str(nums[j]) + str(nums[i])):                    nums[i], nums[j] = nums[j], nums[i]        for x in (nums):            s += str(x)        return str(int(s))</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/13/leetcode6/"/>
      <url>/2020/05/13/leetcode6/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p>给定一个包含非负数的数组和一个目标整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p><p><strong>示例 1:</strong></p><pre><code>输入: [23,2,4,6,7], k = 6输出: True解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [23,2,6,4,7], k = 6输出: True解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</code></pre><h5 id="这道题说是动态规划，我可去他妈的"><a href="#这道题说是动态规划，我可去他妈的" class="headerlink" title="这道题说是动态规划，我可去他妈的"></a>这道题说是动态规划，我可去他妈的</h5><h5 id="（0-0）-0"><a href="#（0-0）-0" class="headerlink" title="（0+0）/ 0 ???"></a>（0+0）/ 0 ???</h5><h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><pre><code>class Solution(object):    def checkSubarraySum(self, nums, k):        """        :type nums: List[int]        :type k: int        :rtype: bool        """        lookup = {}        lookup[0] = -1        # print(lookup)        summing = 0        n = len(nums)        if n &lt; 2 : return False        for i in range(0,n):            summing += nums[i]            if k!= 0:summing %= k            pre = lookup.get(summing,None)            # print(lookup)            if pre != None:                if i - pre &gt; 1:                    return True            else:                lookup[summing] = i        return False</code></pre><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><pre><code>class Solution {public:    bool checkSubarraySum(vector&lt;int&gt;&amp; nums, int k) {        unordered_map&lt;int,long long&gt; pre_sum;        long long sum = 0;        int n = nums.size();        for(int i=0;i&lt;n;++i){            sum += nums[i];            pre_sum[i+1]=sum;        }        if(k==0){            for(int i=2;i&lt;=n;++i){                for(int j=0;j&lt;i-1;++j){                    if(pre_sum[i]-pre_sum[j]==0)return true;                }            }            return false;        }        for(int i=2;i&lt;=n;++i){            for(int j=0;j&lt;i-1;++j){                if((pre_sum[i]-pre_sum[j])%k==0)return true;            }        }        return false;    }};shaftshaft</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jieba</title>
      <link href="/2020/05/13/jieba/"/>
      <url>/2020/05/13/jieba/</url>
      
        <content type="html"><![CDATA[<h2 id="基于结巴的分词，最常用的中文分词工具"><a href="#基于结巴的分词，最常用的中文分词工具" class="headerlink" title="基于结巴的分词，最常用的中文分词工具"></a>基于结巴的分词，最常用的中文分词工具</h2><pre><code>import jieba</code></pre><pre><code>sef_list = jieba.cut('我就危机全文及全文及请问健康科技强',cut_all=False)print('Deafault Mode:'+ '/'.join(sef_list))输出：Deafault Mode:我/就/危机/全文/及/全文/及/请问/健康/科技/强</code></pre><pre><code># 但是健康科技是分开的，我们想让健康科技连起来如代码所示jieba.add_word('健康科技')sef_list = jieba.cut('我就危机全文及全文及请问健康科技强',cut_all=False)print('Deafault Mode:'+ '/'.join(sef_list))输出：Deafault Mode:我/就/危机/全文/及/全文/及/请问/健康科技/强</code></pre><h4 id="判断一句话是否能切分（被字典）"><a href="#判断一句话是否能切分（被字典）" class="headerlink" title="判断一句话是否能切分（被字典）"></a>判断一句话是否能切分（被字典）</h4><pre><code>dic = set(["贪心科技", "人工智能", "教育", "在线", "专注于"])def word_break(str):    could_break = [False] * (len(str) + 1)    could_break[0] = True    for i in range(1, len(could_break)):        for j in range(0, i):            if str[j:i] in dic and could_break[j] == True:                could_break[i] = True    return could_break[len(str)] == True</code></pre><pre><code>def all_possible_segmentations(str):    segs = []    return segs</code></pre><pre><code>import nltknltk.download('stopwords')输出 False</code></pre><h5 id="停用词过滤"><a href="#停用词过滤" class="headerlink" title="停用词过滤"></a>停用词过滤</h5><pre><code># 方法1： 自己建立一个停用词词典stop_words = ["the", "an", "is", "there"]# 在使用时： 假设 word_list包含了文本里的单词word_list = ["we", "are", "the", "students"]filtered_words = [word for word in word_list if word not in stop_words]print (filtered_words)# 方法2：直接利用别人已经构建好的停用词库from nltk.corpus import stopwordscachedStopWords = stopwords.words("english")</code></pre><h5 id="词袋向量：-把文本转换成向量-。-只有向量才能作为模型的输入。"><a href="#词袋向量：-把文本转换成向量-。-只有向量才能作为模型的输入。" class="headerlink" title="词袋向量： 把文本转换成向量 。 只有向量才能作为模型的输入。"></a>词袋向量： 把文本转换成向量 。 只有向量才能作为模型的输入。</h5><pre><code># 方法1： 词袋模型（按照词语出现的个数）from sklearn.feature_extraction.text import CountVectorizervectorizer = CountVectorizer()corpus = [     'He is going from Beijing to Shanghai.',     'He denied my request, but he actually lied.',     'Mike lost the phone, and phone was in the car.',]X = vectorizer.fit_transform(corpus)</code></pre><pre><code>print (X.toarray())print (vectorizer.get_feature_names())[[0 0 1 0 0 0 1 1 1 0 1 0 0 0 0 0 0 1 0 1 0] [1 0 0 1 0 1 0 0 2 0 0 1 0 0 1 0 1 0 0 0 0] [0 1 0 0 1 0 0 0 0 1 0 0 1 1 0 2 0 0 2 0 1]]['actually', 'and', 'beijing', 'but', 'car', 'denied', 'from', 'going', 'he', 'in', 'is', 'lied', 'lost', 'mike', 'my', 'phone', 'request', 'shanghai', 'the', 'to', 'was']</code></pre><pre><code># 方法2：词袋模型（tf-idf方法）from sklearn.feature_extraction.text import TfidfVectorizervectorizer = TfidfVectorizer(smooth_idf=False)X = vectorizer.fit_transform(corpus)</code></pre><pre><code>print (X.toarray())print (vectorizer.get_feature_names())</code></pre><pre><code>[[0.         0.         0.39379499 0.         0.         0.  0.39379499 0.39379499 0.26372909 0.         0.39379499 0.  0.         0.         0.         0.         0.         0.39379499  0.         0.39379499 0.        ] [0.35819397 0.         0.         0.35819397 0.         0.35819397  0.         0.         0.47977335 0.         0.         0.35819397  0.         0.         0.35819397 0.         0.35819397 0.  0.         0.         0.        ] [0.         0.26726124 0.         0.         0.26726124 0.  0.         0.         0.         0.26726124 0.         0.  0.26726124 0.26726124 0.         0.53452248 0.         0.  0.53452248 0.         0.26726124]]['actually', 'and', 'beijing', 'but', 'car', 'denied', 'from', 'going', 'he', 'in', 'is', 'lied', 'lost', 'mike', 'my', 'phone', 'request', 'shanghai', 'the', 'to', 'was']</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> nlp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nlp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy</title>
      <link href="/2020/05/13/numpy/"/>
      <url>/2020/05/13/numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="NumPy-简介"><a href="#NumPy-简介" class="headerlink" title="NumPy - 简介"></a>NumPy - 简介</h2><p>NumPy 是一个 Python 包。 它代表 “Numeric Python”。 它是一个由多维数组对象和用于处理数组的例程集合组成的库。</p><p><strong>Numeric</strong>，即 NumPy 的前身，是由 Jim Hugunin 开发的。 也开发了另一个包 Numarray ，它拥有一些额外的功能。 2005年，Travis Oliphant 通过将 Numarray 的功能集成到 Numeric 包中来创建 NumPy 包。 这个开源项目有很多贡献者。</p><h2 id="NumPy-操作"><a href="#NumPy-操作" class="headerlink" title="NumPy 操作"></a>NumPy 操作</h2><p>使用NumPy，开发人员可以执行以下操作：</p><ul><li>数组的算数和逻辑运算。</li><li>傅立叶变换和用于图形操作的例程。</li><li>与线性代数有关的操作。 NumPy 拥有线性代数和随机数生成的内置函数。</li></ul><h2 id="NumPy-–-MatLab-的替代之一"><a href="#NumPy-–-MatLab-的替代之一" class="headerlink" title="NumPy – MatLab 的替代之一"></a>NumPy – MatLab 的替代之一</h2><p>NumPy 通常与 <strong>SciPy</strong>（Scientific Python）和 <strong>Matplotlib</strong>（绘图库）一起使用。 这种组合广泛用于替代 MatLab，是一个流行的技术计算平台。 但是，Python 作为 MatLab 的替代方案，现在被视为一种更加现代和完整的编程语言。</p><p>NumPy 是开源的，这是它的一个额外的优势。</p><h2 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy - Ndarray 对象"></a>NumPy - Ndarray 对象</h2><p>NumPy 中定义的最重要的对象是称为 <code>ndarray</code> 的 N 维数组类型。 它描述相同类型的元素集合。 可以使用基于零的索引访问集合中的项目。</p><p><code>ndarray</code>中的每个元素在内存中使用相同大小的块。 <code>ndarray</code>中的每个元素是数据类型对象的对象（称为 <code>dtype</code>）。</p><p>从<code>ndarray</code>对象提取的任何元素（通过切片）由一个数组标量类型的 Python 对象表示。 下图显示了<code>ndarray</code>，数据类型对象（<code>dtype</code>）和数组标量类型之间的关系。</p><p>Ndarray</p><p><code>ndarray</code>类的实例可以通过本教程后面描述的不同的数组创建例程来构造。 基本的<code>ndarray</code>是使用 NumPy 中的数组函数创建的，如下所示：</p><pre class="line-numbers language-cpp"><code class="language-cpp">numpy<span class="token punctuation">.</span>array<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>它从任何暴露数组接口的对象，或从返回数组的任何方法创建一个ndarray。</p><pre class="line-numbers language-python"><code class="language-python">numpy<span class="token punctuation">.</span>array<span class="token punctuation">(</span>object<span class="token punctuation">,</span> dtype <span class="token operator">=</span> None<span class="token punctuation">,</span> copy <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">,</span> order <span class="token operator">=</span> None<span class="token punctuation">,</span> subok <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span> ndmin <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面的构造器接受以下参数：</p><table><thead><tr><th>1.</th><th><code>object</code> 任何暴露数组接口方法的对象都会返回一个数组或任何（嵌套）序列。</th></tr></thead><tbody><tr><td>2.</td><td><code>dtype</code> 数组的所需数据类型，可选。</td></tr><tr><td>3.</td><td><code>copy</code> 可选，默认为<code>true</code>，对象是否被复制。</td></tr><tr><td>4.</td><td><code>order</code> <code>C</code>（按行）、<code>F</code>（按列）或<code>A</code>（任意，默认）。</td></tr><tr><td>5.</td><td><code>subok</code> 默认情况下，返回的数组被强制为基类数组。 如果为<code>true</code>，则返回子类。</td></tr><tr><td>6.</td><td><code>ndmin</code> 指定返回数组的最小维数。</td></tr></tbody></table><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><pre><code>import numpy as np a = np.array([1,2,3])  print a#输出 [1, 2, 3]</code></pre><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><pre><code># 多于一个维度  import numpy as np a = np.array([[1,  2],  [3,  4]])  print a#输出     [[1, 2]       [3, 4]]</code></pre><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3"></a>示例 3</h4><pre><code># 最小维度  import numpy as np a = np.array([1,  2,  3,4,5], ndmin =  2)  print a# 输出    [[1, 2, 3, 4, 5]]</code></pre><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4"></a>示例 4</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property"># dtype 参数  </span>import numpy as np a <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dtype <span class="token operator">=</span> complex<span class="token punctuation">)</span>  print a#输出 <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">.</span>j<span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">.</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">.</span>j<span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">.</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">.</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>*<em>ndarray *</em> 对象由计算机内存中的一维连续区域组成，带有将每个元素映射到内存块中某个位置的索引方案。 内存块以按行（C 风格）或按列（FORTRAN 或 MatLab 风格）的方式保存元素。</p><h2 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy - 数据类型"></a>NumPy - 数据类型</h2><table><thead><tr><th align="left">序号</th><th align="left">数据类型及描述</th></tr></thead><tbody><tr><td align="left">1.</td><td align="left"><code>bool_</code> 存储为一个字节的布尔值（真或假）</td></tr><tr><td align="left">2.</td><td align="left"><code>int_</code> 默认整数，相当于 C 的<code>long</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left">3.</td><td align="left"><code>intc</code> 相当于 C 的<code>int</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left">4.</td><td align="left"><code>intp</code> 用于索引的整数，相当于 C 的<code>size_t</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left">5.</td><td align="left"><code>int8</code> 字节（-128 ~ 127）</td></tr><tr><td align="left">6.</td><td align="left"><code>int16</code> 16 位整数（-32768 ~ 32767）</td></tr><tr><td align="left">7.</td><td align="left"><code>int32</code> 32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td align="left">8.</td><td align="left"><code>int64</code> 64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td align="left">9.</td><td align="left"><code>uint8</code> 8 位无符号整数（0 ~ 255）</td></tr><tr><td align="left">10.</td><td align="left"><code>uint16</code> 16 位无符号整数（0 ~ 65535）</td></tr><tr><td align="left">11.</td><td align="left"><code>uint32</code> 32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td align="left">12.</td><td align="left"><code>uint64</code> 64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td align="left">13.</td><td align="left"><code>float_</code> <code>float64</code>的简写</td></tr><tr><td align="left">14.</td><td align="left"><code>float16</code> 半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td align="left">15.</td><td align="left"><code>float32</code> 单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td align="left">16.</td><td align="left"><code>float64</code> 双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td align="left">17.</td><td align="left"><code>complex_</code> <code>complex128</code>的简写</td></tr><tr><td align="left">18.</td><td align="left"><code>complex64</code> 复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td align="left">19.</td><td align="left"><code>complex128</code> 复数，由两个 64 位浮点表示（实部和虚部）</td></tr></tbody></table><p>NumPy 数字类型是<code>dtype</code>（数据类型）对象的实例，每个对象具有唯一的特征。 这些类型可以是<code>np.bool_</code>，<code>np.float32</code>等。</p><h2 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (<code>dtype</code>)</h2><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li>数据类型（整数、浮点或者 Python 对象）</li><li>数据大小</li><li>字节序（小端或大端）</li><li>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分。</li><li>如果数据类型是子序列，它的形状和数据类型。</li></ul><p>字节顺序取决于数据类型的前缀<code>&lt;</code>或<code>&gt;</code>。 <code>&lt;</code>意味着编码是小端（最小有效字节存储在最小地址中）。 <code>&gt;</code>意味着编码是大端（最大有效字节存储在最小地址中）。</p><p><code>dtype</code>可由一下语法构造：</p><pre><code>numpy.dtype(object, align, copy)</code></pre><p>参数为：</p><ul><li><code>Object</code>：被转换为数据类型的对象。</li><li><code>Align</code>：如果为<code>true</code>，则向字段添加间隔，使其类似 C 的结构体。</li><li><code>Copy</code> ? 生成<code>dtype</code>对象的新副本，如果为<code>flase</code>，结果是内建数据类型对象的引用。</li></ul><h4 id="示例-1-1"><a href="#示例-1-1" class="headerlink" title="示例 1"></a>示例 1</h4><pre><code># 使用数组标量类型  import numpy as np dt = np.dtype(np.int32)  print dt#输出 int32</code></pre><h4 id="示例-2-1"><a href="#示例-2-1" class="headerlink" title="示例 2"></a>示例 2</h4><pre><code>#int8，int16，int32，int64 可替换为等价的字符串 'i1'，'i2'，'i4'，以及其他。  import numpy as np dt = np.dtype('i4')  print dt #输出 int32</code></pre><h4 id="示例-3-1"><a href="#示例-3-1" class="headerlink" title="示例 3"></a>示例 3</h4><pre><code># 使用端记号  import numpy as np dt = np.dtype('&gt;i4')  print dt# 输出 &gt;i4</code></pre><p>下面的例子展示了结构化数据类型的使用。 这里声明了字段名称和相应的标量数据类型。</p><h4 id="示例-4-1"><a href="#示例-4-1" class="headerlink" title="示例 4"></a>示例 4</h4><pre><code># 首先创建结构化数据类型。  import numpy as np dt = np.dtype([('age',np.int8)])  print dt # 输出 [('age', 'i1')] </code></pre><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5"></a>示例 5</h4><pre><code># 现在将其应用于 ndarray 对象  import numpy as np dt = np.dtype([('age',np.int8)]) a = np.array([(10,),(20,),(30,)], dtype = dt)  print a# 输出 [(10,) (20,) (30,)]</code></pre><h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例 6"></a>示例 6</h4><pre><code># 文件名称可用于访问 age 列的内容  import numpy as np dt = np.dtype([('age',np.int8)]) a = np.array([(10,),(20,),(30,)], dtype = dt)  print a['age']# 输出 [10 20 30]</code></pre><h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例 7"></a>示例 7</h4><pre><code>import numpy as np student = np.dtype([('name','S20'),  ('age',  'i1'),  ('marks',  'f4')]) a = np.array([('abc',  21,  50),('xyz',  18,  75)], dtype = student)  print a# 输出 [('abc', 21, 50.0), ('xyz', 18, 75.0)]</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L1L2正则化</title>
      <link href="/2020/05/13/ml13/"/>
      <url>/2020/05/13/ml13/</url>
      
        <content type="html"><![CDATA[<h3 id="偏差方差权衡"><a href="#偏差方差权衡" class="headerlink" title="偏差方差权衡"></a>偏差方差权衡</h3><p>降低模型复杂度<br>减少数据维度，降噪<br>增加样本数<br>使用验证集</p><h4 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h4><pre><code>import numpy as npimport matplotlib.pyplot as pltfrom sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScaler</code></pre><pre><code>np.random.seed(42)x = np.random.uniform(-3.,3.,size = 100)X = x.reshape(-1,1)y = 0.5 * x + x + 3 + np.random.normal(0,1,size=100)</code></pre><pre><code>plt.scatter(x,y)plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml13%5C1.png" alt="1"></p><pre><code>from sklearn.linear_model import Ridgefrom sklearn.preprocessing import StandardScalerdef RidgeRe(defree,alpha):    return Pipeline([        ('poly',PolynomialFeatures(defree=defree)),        ('std_scaler',StandardScaler()),        ('ridge_reg',Ridge(alpha=alpha))    ])</code></pre><pre><code>ridge1_reg = RidgeReGRESSION(20,0.0001)ridge1_reg.fit(X,Y)</code></pre><h4 id="LASSO"><a href="#LASSO" class="headerlink" title="LASSO"></a>LASSO</h4><pre><code>from sklearn.linear_model import Lassodef lassoRe(defree,alpha):    return Pipeline([        ('poly',PolynomialFeatures(defree=defree)),        ('std_scaler',StandardScaler()),        ('ridge_reg',Lasso(alpha=alpha))    ])</code></pre><pre><code>lasssol_reg = LassoRegression(20,0.01)lasssol_reg.fit(x,y)lasso_pre = lasssol_reg.predict(x_test)mnean_squared_accury(y_test,lasso_pre)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肺炎预测</title>
      <link href="/2020/05/13/ml12/"/>
      <url>/2020/05/13/ml12/</url>
      
        <content type="html"><![CDATA[<p>1、什么是SEIR模型</p><p>常见的传染病模型按照传染病类型分为SI、SIR、SIRS、SEIR 模型等，用于研究传染病的传播速度、空间范围、传播途径、动力学机理等问题，<br>以指导对传染病的有效地预防和控制。</p><p>首先介绍S、E、I、R几个重要的参数：</p><p>1、S 类：易感者 (Susceptible)，指未得病者，但缺乏免疫能力，与感染者接触后容易受到感染；在视频中，假设某区域的人口数为10000，<br>那么第一天的S=N-I=9999</p><p>2、E 类：暴露者 (Exposed)，指接触过感染者，但暂无能力传染给其他人的人，对潜伏期长的传染病适用；本例中第一天为0个。</p><p>3、I 类：感病者 (Infectious)，指染上传染病的人，可以传播给 S 类成员，将其变为 E 类或 I 类成员；本例中第一天为1个。</p><p>4、R 类：康复者 (Recovered)，指被隔离或因病愈而具有免疫力的人。如免疫期有限，R 类成员可以重新变为 S 类。本例中第一天为0个。</p><p>接下来看看图中的r、β、γ、α：</p><p>1、r：感染患者（I）每天接触的易感者数目，本例为20</p><p>2、β：传染系数；由疾病本身的传播能力，人群的防控能力决定，本例设置为0.03</p><p>3、γ：恢复系数；一般为病程的倒数，例如流感的病程5天的话，那么它的γ就是1/5，本例设置为0.1</p><p>4、α：潜伏者的发病概率；一般为潜伏期的倒数，本例为0.1</p><p>2、怎么理解SEIR模型</p><p>当dt=1时</p><p>St+1-St=-γβItSt/ N</p><p>Et+1-Et=γβItSt/ N-ɑEt</p><p>It+1-It=ɑEt-γIt</p><p>Rt+1-Rt=γIt</p><p>我们看流程图和公式，dS/dt可以理解为当时间t无限接近0时，S的变化量。当t=1时，dS/dt就是每日S的改变数，<br>其余的dE/dt、dI/dt、dR/dt同理。因为S是从一开始接近N，然后慢慢被感染成E，呈下降变化，所以第一条公式右边是带负号。</p><p>每天有多少S减少由每天发病人群接触人数（r）、传染系数（β）、发病人数的比例（I/N）、<br>易感人群的比例（S/N）、总人数（N）所决定的，所以dS/dt=-r<em>β</em>S/N<em>I/N</em>N=-rβSI/N。<br>那么每天E的改变数量dE/dt就是每天S转化为E的数目（rβSI/N）减去每天E转化为I的数目（rβSI/N-αE）。其余的dI/dt、dR/dt同理。</p><pre><code>import mathimport numpy as npimport matplotlibimport matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['KaiTi']plt.rcParams['axes.unicode_minus'] = Falsedef calc(T):    for i in range(0, len(T) - 1):        S.append(S[i] - r * b * S[i] * I[i] / N )        E.append(E[i] + r * b * S[i] * I[i] / N - a * E[i] )        I.append(I[i] + a * E[i] - y * I[i])        R.append(R[i] + y * I[i])def plot(T,S,E,I,R):    plt.figure()    plt.title("SEIR-病毒传播时间曲线")    plt.plot(T,S,color='r',label='易感者')    plt.plot(T, E, color='k', label='潜伏者')    plt.plot(T, I, color='b', label='传染者')    plt.plot(T, R, color='g', label='康复者')    plt.grid(False)    plt.legend()    plt.xlabel("时间(天)")    plt.ylabel("人数")    plt.show()if __name__ == '__main__':    # 首先还是设置一下参数,之后方便修改    N = 10000 # 人口总数    E = [] # 潜伏携带者    E.append(0)    I = [] # 传染者    I.append(1)    S = [] # 易感者    S.append(N - I[0])    R = [] # 康复者    R.append(0)    r = 20 # 传染者接触人数    b = 0.03 # 传染者传染概率    a = 0.1 # 潜伏者患病概率    y = 0.1 # 康复概率    T = [i for i in range(0, 160)] # 时间    calc(T)    plot(T,S,E,I,R)</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml12%5C1.png" alt="1"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混淆矩阵</title>
      <link href="/2020/05/13/ml11/"/>
      <url>/2020/05/13/ml11/</url>
      
        <content type="html"><![CDATA[<pre><code>digits = datasets.load_digits()X = digits.datay = digits.target.copy()</code></pre><pre><code>from sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltX_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.8)</code></pre><pre><code>from sklearn.linear_model import LogisticRegressionlog_reg = LogisticRegression()log_reg.fit(X_train,y_train)log_reg.score(X_test,y_test)# 0.9408901251738526</code></pre><pre><code>y_predict = log_reg.predict(X_test)</code></pre><pre><code>precision_score(y_test,y_predict,average='micro')# 0.9408901251738526</code></pre><pre><code>from sklearn.metrics import confusion_matrixconfusion_matrix(y_test,y_predict)</code></pre><pre><code>array([[137,   0,   0,   0,   1,   1,   0,   0,   0,   0],       [  0, 128,   0,   1,   0,   0,   3,   0,   2,   1],       [  0,   0, 142,   2,   0,   0,   0,   0,   3,   0],       [  0,   0,   2, 131,   0,   0,   0,   1,   8,   2],       [  0,   6,   0,   0, 138,   0,   0,   2,   1,   1],       [  0,   1,   1,   0,   1, 144,   1,   0,   1,   4],       [  1,   0,   0,   0,   1,   0, 144,   0,   2,   0],       [  0,   0,   0,   0,   1,   0,   0, 134,   4,   6],       [  1,   8,   2,   2,   1,   0,   0,   2, 124,   1],       [  0,   2,   0,   0,   0,   1,   0,   0,   4, 131]], dtype=int64)</code></pre><pre><code>cfm = confusion_matrix(y_test,y_predict)plt.matshow(cfm,cmap=plt.cm.gray)plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml11%5C1.png" alt="1"></p><pre><code>row = np.sum(cfm,axis=1)err_mat = cfm/ rownp.fill_diagonal(err_mat,0)err_mat</code></pre><pre><code>plt.matshow(err_mat,cmap=plt.cm.gray)plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml11%5C2.png" alt="2"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv入门五</title>
      <link href="/2020/05/13/opencv4/"/>
      <url>/2020/05/13/opencv4/</url>
      
        <content type="html"><![CDATA[<pre><code>import tensorflow as tfimport numpy as npimport cv2import random</code></pre><pre><code>img1 = cv2.imread('H:\Jupyter\img1.jpg',1)imgInfo = img1.shapeheight = imgInfo[0]width = imgInfo[1]#canny 1 gray 2 高斯  3 cannygray = cv2.cvtColor(img1,cv2.COLOR_BGR2BGRA)imgG = cv2.GaussianBlur(gray,(3,3),0)dst = cv2.Canny(img1,50,50) # 1 data 2 th 图片卷积运算cv2.imshow('dst',dst)cv2.waitKey()</code></pre><pre><code># sobel 1 算子模板  2 图片卷积  3 阈值判决gray = cv2.cvtColor(img,cv2.COLOR_BGR2BGRA)dst = np.zeros((height,width,1),np.uint8)for i in range(0,height-2):    for j in range(0,width-2):        gy = gray[i,j]*1 + gray[i,j+1]*2 = gray[i,j+2]*1 - gray[i+2,j]*1 - \            gray[i+2,j+1]*2        gx = gray[i,j]*1 + gray[i,j+1]*2 = gray[i,j+2]*1 - gray[i+2,j]*1 - \            gray[i+2,j+1]*2        grad = math.sqrt(gx*gx+gy*gy)        if grad &gt; 50:            dst[i,j] = 255        else:            dst[i,j] = 0cv2.imshow('img',dst)cv2.waitKey(0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv入门三</title>
      <link href="/2020/05/13/opencv3/"/>
      <url>/2020/05/13/opencv3/</url>
      
        <content type="html"><![CDATA[<pre><code>import tensorflow as tfimport numpy as npimport cv2</code></pre><pre><code># 0 -255#灰色图片img = cv2.imread('H:\Jupyter\img1.jpg',1)imgInfo = img.shapeheight = imgInfo[0]width = imgInfo[1]gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)dst = np.zeros((height,wigdth,1),np.uint8)for i in range(0,height):    for j in range(0,width):        grayPixel = gray[i,j]        dst[i,j] = 255-grayPixelcv2.imshow('dst',dst)cv2.waitKey(0)</code></pre><pre><code>#彩色图片# RGB 255-r = NEWr#灰色图片img = cv2.imread('H:\Jupyter\img1.jpg',0)imgInfo = img.shapeheight = imgInfo[0]width = imgInfo[1]dst = np.zeros((height,width,3),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r) = img[i,j]        dst[i,j] = (255-b,255-g,255-r)cv2.imshow('dst',dst)cv2.waitKey(0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv入门1</title>
      <link href="/2020/05/13/opencv2/"/>
      <url>/2020/05/13/opencv2/</url>
      
        <content type="html"><![CDATA[<pre><code># import tensorflow as tsimport numpy as npimport cv2import matplotlib.pyplot as plt</code></pre><h4 id="美颜"><a href="#美颜" class="headerlink" title="美颜"></a>美颜</h4><pre><code>img1 = cv2.imread('H:\Jupyter\img1.jpg',1)dst = cv2.cvtColor(img1,cv2.COLOR_BGR2GRAY)cv2.imshow('dd',dst)cv2.waitKey()</code></pre><pre><code>#灰色图片均衡化img = cv2.imread('H:\Jupyter\img1.jpg',1)gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)cv2.imshow('src',gray)dst = cv2.equalizeHist(gray)cv2.imshow('dsd',dst)cv2.waitKey(0)</code></pre><pre><code>#彩色图片均衡化img = cv2.imread('H:\Jupyter\img1.jpg',1)(b,g,r) = cv2.split(img)bH = cv2.equalizeHist(b)gH = cv2.equalizeHist(g)rH = cv2.equalizeHist(r)result = cv2.merge((bH,gH,rH))  #通道合成cv2.imshow('dsd',result)cv2.waitKey(0)</code></pre><pre><code>#YUV图片均衡化img = cv2.imread('H:\Jupyter\img1.jpg',1)imgYUV = cv2.cvtColor(img,cv2.COLOR_BGR2YCrCb)channleYUV = cv2.split(imgYUV)channleYUV[0] = cv2.equalizeHist(channleYUV[0])channles = cv2.merge(channleYUV)result = cv2.cvtColor(channels,cv2.COLOR_YCrCb2BGR)cv2.imshow('dsd',result)cv2.waitKey(0)</code></pre><h4 id="图片修复"><a href="#图片修复" class="headerlink" title="图片修复"></a>图片修复</h4><pre><code>for i in range(200,300):    img1[i,200] = (255,255,255)    img1[i,200+1] = (255,255,255)    img1[i,200-1] = (255,255,255)for i in range(150,250):    img1[250,i] = (255,255,255)    img1[250,i+1] = (255,255,255)    img1[250,i-1] = (255,255,255)cv2.imwrite('dd.jpg',img1)cv2.imshow('aa',img1)cv2.waitKey(0)</code></pre><pre><code>img = cv2.imread('dd.jpg',1)cv2.imshow('sree',img)cv2.waitKey(0)imgInfo = img.shapeheight = imgInfo[0]width = imgInfo[1]paint = np.zeros((height,width,1),np.uint8)for i in range(200,300):    paint[i,200] = 255    paint[i,200+1] = 255    paint[i,200-1] = 255for i in range(150,250):    paint[250,i] = 255    paint[250,i+1] = 255    paint[250,i-1] = 255cv2.imshow('aa',paint)imgDst = cv2.inpaint(img,paint,3,cv2.INPAINT_TELEA)cv2.imshow('aa',imgDst)cv2.waitKey(0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv入门二</title>
      <link href="/2020/05/13/opencv1/"/>
      <url>/2020/05/13/opencv1/</url>
      
        <content type="html"><![CDATA[<pre><code>import tensorflow as tsimport numpy as npimport cv2# import matplotlib.pyplot as plt</code></pre><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code>img0 = cv2.imread('H:\Jupyter\img1.jpg',0)img1 = cv2.imread('H:\Jupyter\img1.jpg',1)print(img0.shape)print(img1.shape)cv2.imshow('src',img0)cv2.imshow('src',img1)cv2.waitKey(0)</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code>img1 = cv2.imread('H:\Jupyter\img1.jpg',1)dst = cv2.cvtColor(img1,cv2.COLOR_BGR2GRAY)cv2.imshow('dd',dst)cv2.waitKey()</code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><pre><code>img1 = cv2.imread('H:\Jupyter\img1.jpg',1)imgInfo = img1.shapeheight = imgInfo[0]width = imgInfo[1]# RGB R = B = G = gray   (r+g+b)/3dst = np.zeros((height,width),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r) = img1[i,j]        gray = (int(b) + int(g) + int(r)) /3        dst[i,j] = np.uint8(gray)cv2.imshow('qq',dst)cv2.waitKey(0)</code></pre><h4 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h4><pre><code># gray = r*0.229 + g*0.587 + b*0.114img1 = cv2.imread('H:\Jupyter\img1.jpg',1)imgInfo = img1.shapeheight = imgInfo[0]width = imgInfo[1]# RGB R = B = G = gray   (r+g+b)/3dst = np.zeros((height,width),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r) = img1[i,j]        b = int(b)        g = int(g)        r = int(r)        gray = r*0.229 + g*0.587 + b*0.114        dst[i,j] = np.uint8(gray)cv2.imshow('qq',dst)cv2.waitKey(0)</code></pre><pre><code>#灰度优化# gray = r*0.229 + g*0.587 + b*0.114img1 = cv2.imread('H:\Jupyter\img1.jpg',1)imgInfo = img1.shapeheight = imgInfo[0]width = imgInfo[1]# RGB R = B = G = gray   (r+g+b)/3dst = np.zeros((height,width),np.uint8)for i in range(0,height):    for j in range(0,width):        (b,g,r) = img1[i,j]        b = int(b)        g = int(g)        r = int(r)#         gray = (r*1+g*2 + b*1)/4        gray = (r+(g&lt;&lt;1) + b)&gt;&gt;2        dst[i,j] = np.uint8(gray)cv2.imshow('qq',dst)cv2.waitKey(0)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集成学习</title>
      <link href="/2020/05/13/ml10/"/>
      <url>/2020/05/13/ml10/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npimport matplotlib.pyplot as pltimport warningswarnings.filterwarnings</code></pre><pre><code>from sklearn import datasetsX,y = datasets.make_moons(n_samples=500,noise=0.3,random_state=42)</code></pre><pre><code>plt.scatter(X[y==0,0],X[y==0,1])plt.scatter(X[y==1,0],X[y==1,1])plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml10%5C1.png" alt="1"></p><pre><code>from sklearn.model_selection import train_test_splitX_train,X_test,y_train,y_test = train_test_split(X,y,random_state=666)</code></pre><pre><code>from sklearn.linear_model import LogisticRegressionlog_clf =  LogisticRegression()log_clf.fit(X_train,y_train)log_clf.score(X_test,y_test)</code></pre><pre><code>0.824</code></pre><pre><code>from sklearn.svm import SVCsvm_clf = SVC()svm_clf.fit(X_train,y_train)svm_clf.score(X_test,y_test)</code></pre><pre><code>0.88</code></pre><pre><code>from sklearn.tree import DecisionTreeClassifierdt_clf = DecisionTreeClassifier()dt_clf.fit(X_train,y_train)dt_clf.score(X_test,y_test)</code></pre><pre><code>0.84</code></pre><pre><code>y_predict1 = log_clf.predict(X_test)y_predict2 = svm_clf.predict(X_test)y_predict3 = dt_clf.predict(X_test)</code></pre><pre><code>print(y_predict1)print(y_predict2)print(y_predict3)</code></pre><pre><code>y_predict = np.array((y_predict1 + y_predict2 + y_predict3)) &gt;= 2</code></pre><pre><code>y_predict[:10]#array([ True,  True, False, False, False,  True, False,  True, False,#        True])</code></pre><pre><code>from sklearn.metrics import accuracy_scoreaccuracy_score(y_test,y_predict)</code></pre><pre><code>0.896</code></pre><h2 id="Voting-Classifer"><a href="#Voting-Classifer" class="headerlink" title="Voting Classifer"></a>Voting Classifer</h2><h4 id="少数服从多数"><a href="#少数服从多数" class="headerlink" title="少数服从多数"></a>少数服从多数</h4><pre><code>from sklearn.ensemble import VotingClassifiervot_clf = VotingClassifier(estimators=[    ('log_clf',LogisticRegression()),    ('svm_clf',SVC()),    ('dt_clf',DecisionTreeClassifier(random_state=666))],                          voting='hard'                          )</code></pre><pre><code>vot_clf.fit(X_train,y_train)</code></pre><pre><code>VotingClassifier(estimators=[('log_clf',                              LogisticRegression(C=1.0, class_weight=None,                                                 dual=False, fit_intercept=True,                                                 intercept_scaling=1,                                                 l1_ratio=None, max_iter=100,                                                 multi_class='warn',                                                 n_jobs=None, penalty='l2',                                                 random_state=None,                                                 solver='warn', tol=0.0001,                                                 verbose=0, warm_start=False)),                             ('svm_clf',                              SVC(C=1.0, cache_size=200, class_weight=None,                                  coef0=0.0, decision_f...                             ('dt_clf',                              DecisionTreeClassifier(class_weight=None,                                                     criterion='gini',                                                     max_depth=None,                                                     max_features=None,                                                     max_leaf_nodes=None,                                                     min_impurity_decrease=0.0,                                                     min_impurity_split=None,                                                     min_samples_leaf=1,                                                     min_samples_split=2,                                                     min_weight_fraction_leaf=0.0,                                                     presort=False,                                                     random_state=666,                                                     splitter='best'))],                 flatten_transform=True, n_jobs=None, voting='hard',                 weights=None)</code></pre><pre><code>vot_clf.score(X_test,y_test)# 0.888</code></pre><h2 id="Soft-Voting"><a href="#Soft-Voting" class="headerlink" title="Soft Voting"></a>Soft Voting</h2><pre><code>vot_clf1 = VotingClassifier(estimators=[    ('log_clf',LogisticRegression()),    ('svm_clf',SVC(probability=True)),    ('dt_clf',DecisionTreeClassifier(random_state=666))],                          voting='soft'                          )</code></pre><pre><code>vot_clf1.fit(X_train,y_train)</code></pre><pre><code>VotingClassifier(estimators=[('log_clf',                              LogisticRegression(C=1.0, class_weight=None,                                                 dual=False, fit_intercept=True,                                                 intercept_scaling=1,                                                 l1_ratio=None, max_iter=100,                                                 multi_class='warn',                                                 n_jobs=None, penalty='l2',                                                 random_state=None,                                                 solver='warn', tol=0.0001,                                                 verbose=0, warm_start=False)),                             ('svm_clf',                              SVC(C=1.0, cache_size=200, class_weight=None,                                  coef0=0.0, decision_f...                             ('dt_clf',                              DecisionTreeClassifier(class_weight=None,                                                     criterion='gini',                                                     max_depth=None,                                                     max_features=None,                                                     max_leaf_nodes=None,                                                     min_impurity_decrease=0.0,                                                     min_impurity_split=None,                                                     min_samples_leaf=1,                                                     min_samples_split=2,                                                     min_weight_fraction_leaf=0.0,                                                     presort=False,                                                     random_state=666,                                                     splitter='best'))],                 flatten_transform=True, n_jobs=None, voting='soft',                 weights=None)</code></pre><pre><code>vot_clf1.score(X_test,y_test)# 0.856</code></pre><h3 id="Bagging-放回取样-和Pasting（不放回取样）"><a href="#Bagging-放回取样-和Pasting（不放回取样）" class="headerlink" title="Bagging(放回取样)和Pasting（不放回取样）"></a>Bagging(放回取样)和Pasting（不放回取样）</h3><pre><code>from sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import BaggingClassifierbag_clf = BaggingClassifier(DecisionTreeClassifier(),                           n_estimators=500,                            max_samples=100,                            bootstrap=True                           )</code></pre><pre><code>bag_clf.fit(X_train,y_train)</code></pre><pre><code>BaggingClassifier(base_estimator=DecisionTreeClassifier(class_weight=None,                                                        criterion='gini',                                                        max_depth=None,                                                        max_features=None,                                                        max_leaf_nodes=None,                                                        min_impurity_decrease=0.0,                                                        min_impurity_split=None,                                                        min_samples_leaf=1,                                                        min_samples_split=2,                                                        min_weight_fraction_leaf=0.0,                                                        presort=False,                                                        random_state=None,                                                        splitter='best'),                  bootstrap=True, bootstrap_features=False, max_features=1.0,                  max_samples=100, n_estimators=500, n_jobs=None,                  oob_score=False, random_state=None, verbose=0,                  warm_start=False)</code></pre><pre><code>bag_clf.score(X_test,y_test)# 0.872</code></pre><pre><code>bag_clf1 = BaggingClassifier(DecisionTreeClassifier(),                           n_estimators=5000,                            max_samples=100,                            bootstrap=True                           )</code></pre><pre><code>bag_clf1.fit(X_train,y_train)</code></pre><pre><code>BaggingClassifier(base_estimator=DecisionTreeClassifier(class_weight=None,                                                        criterion='gini',                                                        max_depth=None,                                                        max_features=None,                                                        max_leaf_nodes=None,                                                        min_impurity_decrease=0.0,                                                        min_impurity_split=None,                                                        min_samples_leaf=1,                                                        min_samples_split=2,                                                        min_weight_fraction_leaf=0.0,                                                        presort=False,                                                        random_state=None,                                                        splitter='best'),                  bootstrap=True, bootstrap_features=False, max_features=1.0,                  max_samples=100, n_estimators=5000, n_jobs=None,                  oob_score=False, random_state=None, verbose=0,                  warm_start=False)</code></pre><pre><code>bag_clf1.score(X_test,y_test)# 0.872</code></pre><h3 id="OOB-Out-of-Bag"><a href="#OOB-Out-of-Bag" class="headerlink" title="OOB Out-of-Bag"></a>OOB Out-of-Bag</h3><p>放回取样导致一部分样本很有可能没有取到，大约有37%的样本没有取到，不使用测试集数据，而使用这部分样本做测试验证</p><pre><code>bag_clf2 = BaggingClassifier(DecisionTreeClassifier(),                           n_estimators=5000,                            max_samples=100,                            bootstrap=True,                             oob_score=True                           )</code></pre><pre><code>bag_clf2.fit(X,y)</code></pre><pre><code>bag_clf2.oob_score_# 0.918</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LGB</title>
      <link href="/2020/05/13/ml9/"/>
      <url>/2020/05/13/ml9/</url>
      
        <content type="html"><![CDATA[<p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C1.png" alt="1"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C2.png" alt="2"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C3.png" alt="3"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C4.png" alt="4"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C5.png" alt="5"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C6.png" alt="6"></p><pre><code>import datetimeimport numpy as npimport pandas as pdimport lightgbm as lgbfrom sklearn.datasets import load_breast_cancerfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_scoreimport matplotlib.pyplot as plt%matplotlib inline</code></pre><pre><code># 加载数据集breast = load_breast_cancer()# 获取特征值和目标指X,y = breast.data,breast.target# 获取特征名称feature_name = breast.feature_names</code></pre><pre><code># 数据集划分X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)</code></pre><pre><code># 数据格式转换lgb_train = lgb.Dataset(X_train, y_train)lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</code></pre><pre><code># 参数设置boost_round = 50 # 迭代次数              early_stop_rounds = 10 # 验证数据若在early_stop_rounds轮中未提高，则提前停止params = {    'boosting_type': 'gbdt',  # 设置提升类型    'objective': 'regression',  # 目标函数    'metric': {'l2', 'auc'},  # 评估函数    'num_leaves': 31,  # 叶子节点数    'learning_rate': 0.05,  # 学习速率    'feature_fraction': 0.9,  # 建树的特征选择比例    'bagging_fraction': 0.8,  # 建树的样本采样比例    'bagging_freq': 5,  # k 意味着每 k 次迭代执行bagging    'verbose': 1  # &lt;0 显示致命的, =0 显示错误 (警告), &gt;0 显示信息}</code></pre><pre><code>results = {}gbm = lgb.train(params,                lgb_train,                num_boost_round= boost_round,                valid_sets=(lgb_eval, lgb_train),                valid_names=('validate','train'),                early_stopping_rounds = early_stop_rounds,                evals_result= results)</code></pre><pre><code># 模型预测y_pred = gbm.predict(X_test, num_iteration=gbm.best_iteration)y_pred</code></pre><pre><code># 模型评估lgb.plot_metric(results)plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml9%5C7.png" alt="7"></p><pre><code># 绘制重要的特征lgb.plot_importance(gbm,importance_type = "split")plt.show()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2020/05/13/ml8/"/>
      <url>/2020/05/13/ml8/</url>
      
        <content type="html"><![CDATA[<h3 id="XGBoots"><a href="#XGBoots" class="headerlink" title="XGBoots"></a>XGBoots</h3><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C1.png" alt="1"></p><p>叶节点越多，则决策树越复杂 每个叶子节点输出值的绝对值越大，则决策树月复杂</p><p>Type <em>Markdown</em> and LaTeX: 𝛼2</p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C2.png" alt="2"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C3.png" alt="3"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C4.png" alt="4"></p><p>正则项用来衡量树的复杂度：树的叶子节点个数T和每棵树的叶子节点输出分数W的平方和（相当于L2正则化）<img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C5.png" alt="5"></p><p>缺失值处理 将特征k的缺失值都放在右子树。枚举划分点，计算最大的gain 将特征值k的缺失值都放在左子树，枚举划分点，计算 最多达的gain 最后求出最大增益，确定缺失值的划分</p><p>为了减少数据排序的时间，采用BLock结构存储格式 OUT-of core 缓存优化：使用缓存与其，将梯度信息放入Buffer中</p><pre><code>import timeimport numpy as npimport xgboost as xgbfrom xgboost import plot_importance,plot_treefrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_scorefrom sklearn.datasets import load_bostonimport matplotlibimport matplotlib.pyplot as pltimport os%matplotlib inline</code></pre><pre><code>#以鸢尾花数据集做例子iris = load_iris()X,y = iris.data,iris.targetX_train,X_test,y_train,y_test = train_test_split(X,y,random_state=123456)</code></pre><pre><code># 训练算法参数设置params = {    # 通用参数    'booster': 'gbtree', # 使用的弱学习器,有两种选择gbtree（默认）和gblinear,gbtree是基于                        # 树模型的提升计算，gblinear是基于线性模型的提升计算    'nthread': 4, # XGBoost运行时的线程数，缺省时是当前系统获得的最大线程数    'silent':0, # 0：表示打印运行时信息，1：表示以缄默方式运行，默认为0    'num_feature':4, # boosting过程中使用的特征维数    'seed': 1000, # 随机数种子    # 任务参数    'objective': 'multi:softmax', # 多分类的softmax,objective用来定义学习任务及相应的损失函数    'num_class': 3, # 类别总数    # 提升参数    'gamma': 0.1, # 叶子节点进行划分时需要损失函数减少的最小值    'max_depth': 6, # 树的最大深度，缺省值为6，可设置其他值    'lambda': 2, # 正则化权重    'subsample': 0.7, # 训练模型的样本占总样本的比例，用于防止过拟合    'colsample_bytree': 0.7, # 建立树时对特征进行采样的比例    'min_child_weight': 3, # 叶子节点继续划分的最小的样本权重和    'eta': 0.1, # 加法模型中使用的收缩步长   }plst = params.items()</code></pre><pre><code>#数据集格式转换dtrain = xgb.DMatrix(X_train,y_train)dtest = xgb.DMatrix(X_test,y_test)</code></pre><pre><code>#num_rounds = 10model = xgb.train(plst,dtrain,num_rounds)</code></pre><pre><code>y_predict = model.predict(dtest)y_predict1 = np.array(y_predict)y_predict1</code></pre><pre><code>#对测试集进行预测accuracy = accuracy_score(y_test,y_predict)accuracy</code></pre><pre><code>0.9736842105263158</code></pre><pre><code>#显示中要特征plot_importance(model)plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml8%5C6.png" alt="6"></p><pre><code>plot_tree(model,num_trees=5)</code></pre><h2 id="基于XGBoost原生接口的回归问题"><a href="#基于XGBoost原生接口的回归问题" class="headerlink" title="基于XGBoost原生接口的回归问题"></a>基于XGBoost原生接口的回归问题</h2><p>以波士顿房价数据集做例子</p><pre><code>boston = load_boston()X,y = boston.data,boston.targetfeature_name = boston.feature_names</code></pre><pre><code>X_train,X_test,y_train,y_test = train_test_split(X,y,random_state=123456)</code></pre><pre><code>#参数设置params = {        'booster': 'gbtree',        'objective': 'reg:gamma', # 回归的损失函数，gmma回归        'gamma': 0.1,        'max_depth': 5,        'lambda': 3,        'subsample': 0.7,        'colsample_bytree': 0.7,        'min_child_weight': 3,        'silent': 1,        'eta': 0.1,        'seed': 1000,        'nthread': 4,    }plst = params.items()</code></pre><pre><code>#数据集格式转换dtrain = xgb.DMatrix(X_train,y_train)dtest = xgb.DMatrix(X_test,y_test)</code></pre><pre><code>num_rounds = 30model = xgb.train(plst,dtrain,num_rounds)</code></pre><pre><code>y_predict = model.predict(dtest)</code></pre><pre><code>plot_tree(model,num_trees=17)</code></pre><h2 id="基于sklearrn的接口实现分类"><a href="#基于sklearrn的接口实现分类" class="headerlink" title="基于sklearrn的接口实现分类"></a>基于sklearrn的接口实现分类</h2><pre><code>model = xgb.XGBClassifier(max_depth=5,n_estimator=50,silent=True,objective='muiti:softmax',feature_names=feature_anme)models.fit</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法评价指标</title>
      <link href="/2020/05/13/ml7/"/>
      <url>/2020/05/13/ml7/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npfrom math import sqrtdef accuracy_score(y_true, y_predict):    """计算y_true和y_predict之间的准确率"""    assert len(y_true) == len(y_predict), \        "the size of y_true must be equal to the size of y_predict"    return np.sum(y_true == y_predict) / len(y_true)def mean_squared_error(y_true, y_predict):    """计算y_true和y_predict之间的MSE"""    assert len(y_true) == len(y_predict), \        "the size of y_true must be equal to the size of y_predict"    return np.sum((y_true - y_predict)**2) / len(y_true)def root_mean_squared_error(y_true, y_predict):    """计算y_true和y_predict之间的RMSE"""    return sqrt(mean_squared_error(y_true, y_predict))def mean_absolute_error(y_true, y_predict):    """计算y_true和y_predict之间的RMSE"""    assert len(y_true) == len(y_predict), \        "the size of y_true must be equal to the size of y_predict"    return np.sum(np.absolute(y_true - y_predict)) / len(y_true)def r2_score(y_true, y_predict):    """计算y_true和y_predict之间的R Square"""    return 1 - mean_squared_error(y_true, y_predict)/np.var(y_true)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN</title>
      <link href="/2020/05/13/ml6/"/>
      <url>/2020/05/13/ml6/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npfrom math import sqrtfrom collections import Counterfrom .metrics import accuracy_scoreclass KNNClassifier:    def __init__(self, k):        """初始化kNN分类器"""        assert k &gt;= 1, "k must be valid"        self.k = k        self._X_train = None        self._y_train = None    def fit(self, X_train, y_train):        """根据训练数据集X_train和y_train训练kNN分类器"""        assert X_train.shape[0] == y_train.shape[0], \            "the size of X_train must be equal to the size of y_train"        assert self.k &lt;= X_train.shape[0], \            "the size of X_train must be at least k."        self._X_train = X_train        self._y_train = y_train        return self    def predict(self, X_predict):        """给定待预测数据集X_predict，返回表示X_predict的结果向量"""        assert self._X_train is not None and self._y_train is not None, \                "must fit before predict!"        assert X_predict.shape[1] == self._X_train.shape[1], \                "the feature number of X_predict must be equal to X_train"        y_predict = [self._predict(x) for x in X_predict]        return np.array(y_predict)    def _predict(self, x):        """给定单个待预测数据x，返回x的预测结果值"""        assert x.shape[0] == self._X_train.shape[1], \            "the feature number of x must be equal to X_train"        distances = [sqrt(np.sum((x_train - x) ** 2))                     for x_train in self._X_train]        nearest = np.argsort(distances)        topK_y = [self._y_train[i] for i in nearest[:self.k]]        votes = Counter(topK_y)        return votes.most_common(1)[0][0]    def score(self, X_test, y_test):        """根据测试数据集 X_test 和 y_test 确定当前模型的准确度"""        y_predict = self.predict(X_test)        return accuracy_score(y_test, y_predict)    def __repr__(self):        return "KNN(k=%d)" % self.k</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SimpleLinerRegression</title>
      <link href="/2020/05/13/ml5/"/>
      <url>/2020/05/13/ml5/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npfrom .metrics import r2_scoreclass SimpleLinearRegression:    def __init__(self):        """初始化Simple Linear Regression模型"""        self.a_ = None        self.b_ = None    def fit(self, x_train, y_train):        """根据训练数据集x_train, y_train训练Simple Linear Regression模型"""        assert x_train.ndim == 1, \            "Simple Linear Regressor can only solve single feature training data."        assert len(x_train) == len(y_train), \            "the size of x_train must be equal to the size of y_train"        x_mean = np.mean(x_train)        y_mean = np.mean(y_train)        self.a_ = (x_train - x_mean).dot(y_train - y_mean) / (x_train - x_mean).dot(x_train - x_mean)        self.b_ = y_mean - self.a_ * x_mean        return self    def predict(self, x_predict):        """给定待预测数据集x_predict，返回表示x_predict的结果向量"""        assert x_predict.ndim == 1, \            "Simple Linear Regressor can only solve single feature training data."        assert self.a_ is not None and self.b_ is not None, \            "must fit before predict!"        return np.array([self._predict(x) for x in x_predict])    def _predict(self, x_single):        """给定单个待预测数据x，返回x的预测结果值"""        return self.a_ * x_single + self.b_    def score(self, x_test, y_test):        """根据测试数据集 x_test 和 y_test 确定当前模型的准确度"""        y_predict = self.predict(x_test)        return r2_score(y_test, y_predict)    def __repr__(self):        return "SimpleLinearRegression()"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA降维</title>
      <link href="/2020/05/13/ml4/"/>
      <url>/2020/05/13/ml4/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npclass PCA:    def __init__(self, n_components):        """初始化PCA"""        assert n_components &gt;= 1, "n_components must be valid"        self.n_components = n_components        self.components_ = None    def fit(self, X, eta=0.01, n_iters=1e4):        """获得数据集X的前n个主成分"""        assert self.n_components &lt;= X.shape[1], \            "n_components must not be greater than the feature number of X"        def demean(X):            return X - np.mean(X, axis=0)        def f(w, X):            return np.sum((X.dot(w) ** 2)) / len(X)        def df(w, X):            return X.T.dot(X.dot(w)) * 2. / len(X)        def direction(w):            return w / np.linalg.norm(w)        def first_component(X, initial_w, eta=0.01, n_iters=1e4, epsilon=1e-8):            w = direction(initial_w)            cur_iter = 0            while cur_iter &lt; n_iters:                gradient = df(w, X)                last_w = w                w = w + eta * gradient                w = direction(w)                if (abs(f(w, X) - f(last_w, X)) &lt; epsilon):                    break                cur_iter += 1            return w        X_pca = demean(X)        self.components_ = np.empty(shape=(self.n_components, X.shape[1]))        for i in range(self.n_components):            initial_w = np.random.random(X_pca.shape[1])            w = first_component(X_pca, initial_w, eta, n_iters)            self.components_[i,:] = w            X_pca = X_pca - X_pca.dot(w).reshape(-1, 1) * w        return self    def transform(self, X):        """将给定的X，映射到各个主成分分量中"""        assert X.shape[1] == self.components_.shape[1]        return X.dot(self.components_.T)    def inverse_transform(self, X):        """将给定的X，反向映射回原来的特征空间"""        assert X.shape[1] == self.components_.shape[0]        return X.dot(self.components_)    def __repr__(self):        return "PCA(n_components=%d)" % self.n_components</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinerRegression</title>
      <link href="/2020/05/13/ml3/"/>
      <url>/2020/05/13/ml3/</url>
      
        <content type="html"><![CDATA[<pre><code>import numpy as npfrom .metrics import r2_scoreclass LinearRegression:    def __init__(self):        """初始化Linear Regression模型"""        self.coef_ = None        self.intercept_ = None        self._theta = None    def fit_normal(self, X_train, y_train):        """根据训练数据集X_train, y_train训练Linear Regression模型"""        assert X_train.shape[0] == y_train.shape[0], \            "the size of X_train must be equal to the size of y_train"        X_b = np.hstack([np.ones((len(X_train), 1)), X_train])        self._theta = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y_train)        self.intercept_ = self._theta[0]        self.coef_ = self._theta[1:]        return self    def fit_gd(self, X_train, y_train, eta=0.01, n_iters=1e4):        """根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型"""        assert X_train.shape[0] == y_train.shape[0], \            "the size of X_train must be equal to the size of y_train"        def J(theta, X_b, y):            try:                return np.sum((y - X_b.dot(theta)) ** 2) / len(y)            except:                return float('inf')        def dJ(theta, X_b, y):            # res = np.empty(len(theta))            # res[0] = np.sum(X_b.dot(theta) - y)            # for i in range(1, len(theta)):            #     res[i] = (X_b.dot(theta) - y).dot(X_b[:, i])            # return res * 2 / len(X_b)            return X_b.T.dot(X_b.dot(theta) - y) * 2. / len(X_b)        def gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8):            theta = initial_theta            cur_iter = 0            while cur_iter &lt; n_iters:                gradient = dJ(theta, X_b, y)                last_theta = theta                theta = theta - eta * gradient                if (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &lt; epsilon):                    break                cur_iter += 1            return theta        X_b = np.hstack([np.ones((len(X_train), 1)), X_train])        initial_theta = np.zeros(X_b.shape[1])        self._theta = gradient_descent(X_b, y_train, initial_theta, eta, n_iters)        self.intercept_ = self._theta[0]        self.coef_ = self._theta[1:]        return self    def fit_sgd(self, X_train, y_train, n_iters=5, t0=5, t1=50):        """根据训练数据集X_train, y_train, 使用梯度下降法训练Linear Regression模型"""        assert X_train.shape[0] == y_train.shape[0], \            "the size of X_train must be equal to the size of y_train"        assert n_iters &gt;= 1        def dJ_sgd(theta, X_b_i, y_i):            return X_b_i * (X_b_i.dot(theta) - y_i) * 2.        def sgd(X_b, y, initial_theta, n_iters, t0=5, t1=50):            def learning_rate(t):                return t0 / (t + t1)            theta = initial_theta            m = len(X_b)            for cur_iter in range(n_iters):                indexes = np.random.permutation(m)                X_b_new = X_b[indexes]                y_new = y[indexes]                for i in range(m):                    gradient = dJ_sgd(theta, X_b_new[i], y_new[i])                    theta = theta - learning_rate(cur_iter * m + i) * gradient            return theta        X_b = np.hstack([np.ones((len(X_train), 1)), X_train])        initial_theta = np.random.randn(X_b.shape[1])        self._theta = sgd(X_b, y_train, initial_theta, n_iters, t0, t1)        self.intercept_ = self._theta[0]        self.coef_ = self._theta[1:]        return self    def predict(self, X_predict):        """给定待预测数据集X_predict，返回表示X_predict的结果向量"""        assert self.intercept_ is not None and self.coef_ is not None, \            "must fit before predict!"        assert X_predict.shape[1] == len(self.coef_), \            "the feature number of X_predict must be equal to X_train"        X_b = np.hstack([np.ones((len(X_predict), 1)), X_predict])        return X_b.dot(self._theta)    def score(self, X_test, y_test):        """根据测试数据集 X_test 和 y_test 确定当前模型的准确度"""        y_predict = self.predict(X_test)        return r2_score(y_test, y_predict)    def __repr__(self):        return "LinearRegression()"</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预测员工离职率</title>
      <link href="/2020/05/13/ml2/"/>
      <url>/2020/05/13/ml2/</url>
      
        <content type="html"><![CDATA[<h3 id="使用决策树和随机森林预测员工离职率"><a href="#使用决策树和随机森林预测员工离职率" class="headerlink" title="使用决策树和随机森林预测员工离职率"></a>使用决策树和随机森林预测员工离职率</h3><p>我们的任务是帮助人事部门理解员工为何离职, 预测一个员工离职的可能性. 数据来源: <a href="https://www.kaggle.com/ludobenistant/hr-analytics" target="_blank" rel="noopener">https://www.kaggle.com/ludobenistant/hr-analytics</a></p><pre><code>import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib as matplotimport seaborn as sns%matplotlib inline</code></pre><h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><pre><code># 检测是否有缺失数据df.isnull().any()</code></pre><pre><code># 数据的样例df.head()</code></pre><pre><code># 重命名df = df.rename(columns={'satisfaction_level': 'satisfaction',                         'last_evaluation': 'evaluation',                        'number_project': 'projectCount',                        'average_montly_hours': 'averageMonthlyHours',                        'time_spend_company': 'yearsAtCompany',                        'Work_accident': 'workAccident',                        'promotion_last_5years': 'promotion',                        'sales' : 'department',                        'left' : 'turnover'                        })</code></pre><pre><code># 将预测标签‘是否离职’放在第一列front = df['turnover']df.drop(labels=['turnover'], axis=1, inplace = True)df.insert(0, 'turnover', front)df.head()</code></pre><h4 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h4><pre><code># 共14999个样本，每一个样本中包含10个特征df.shape</code></pre><pre><code># 特征数据类型. df.dtypes</code></pre><pre><code># 离职率turnover_rate = df.turnover.value_counts() / len(df)turnover_rate</code></pre><pre><code># 显示统计数据df.describe()</code></pre><pre><code># 分组的平均数据统计turnover_Summary = df.groupby('turnover')turnover_Summary.mean()</code></pre><pre><code># 相关性矩阵corr = df.corr()sns.heatmap(corr,             xticklabels=corr.columns.values,            yticklabels=corr.columns.values)corr</code></pre><pre><code># 比较离职和未离职员工的满意度emp_population = df['satisfaction'][df['turnover'] == 0].mean()emp_turnover_satisfaction = df[df['turnover']==1]['satisfaction'].mean()print( '未离职员工满意度: ' + str(emp_population))print( '离职员工满意度: ' + str(emp_turnover_satisfaction) )</code></pre><pre><code>未离职员工满意度: 0.666809590479524离职员工满意度: 0.4400980117614114</code></pre><pre><code>from sklearn.metrics import roc_auc_scorefrom sklearn.metrics import classification_reportfrom sklearn.ensemble import RandomForestClassifierfrom sklearn import treefrom sklearn.tree import DecisionTreeClassifierfrom sklearn.tree import export_graphvizfrom sklearn.externals.six import StringIO  from IPython.display import Image  import pydotplus </code></pre><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><pre><code># 实例化dtree = tree.DecisionTreeClassifier(    criterion='entropy',    #max_depth=3, # 定义树的深度, 可以用来防止过拟合    min_weight_fraction_leaf=0.01 # 定义叶子节点最少需要包含多少个样本(使用百分比表达), 防止过拟合    )# 训练dtree = dtree.fit(X_train,y_train)# 指标计算dt_roc_auc = roc_auc_score(y_test, dtree.predict(X_test))print ("决策树 AUC = %2.2f" % dt_roc_auc)print(classification_report(y_test, dtree.predict(X_test)))</code></pre><pre><code>决策树 AUC = 0.93              precision    recall  f1-score   support           0       0.97      0.98      0.97      1714           1       0.93      0.89      0.91       536    accuracy                           0.96      2250   macro avg       0.95      0.93      0.94      2250weighted avg       0.96      0.96      0.96      2250</code></pre><h4 id="决策树的特征重要性分析"><a href="#决策树的特征重要性分析" class="headerlink" title="决策树的特征重要性分析"></a>决策树的特征重要性分析</h4><pre><code># 获取特征重要性importances = dtree.feature_importances_# 获取特征名称feat_names = df.drop(['turnover'],axis=1).columns# 排序indices = np.argsort(importances)[::-1]# 绘图plt.figure(figsize=(12,6))plt.title("Feature importances by Decision Tree")plt.bar(range(len(indices)), importances[indices], color='lightblue',  align="center")plt.step(range(len(indices)), np.cumsum(importances[indices]), where='mid', label='Cumulative')plt.xticks(range(len(indices)), feat_names[indices], rotation='vertical',fontsize=14)plt.xlim([-1, len(indices)])plt.show()</code></pre><h4 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h4><pre><code># 实例化随机森林rf = RandomForestClassifier(    criterion='entropy',    n_estimators=3,     max_depth=None, # 定义树的深度, 可以用来防止过拟合    min_samples_split=10, # 定义至少多少个样本的情况下才继续分叉    #min_weight_fraction_leaf=0.02 # 定义叶子节点最少需要包含多少个样本(使用百分比表达), 防止过拟合    )# 模型训练rf.fit(X_train, y_train)# 计算指标参数rf_roc_auc = roc_auc_score(y_test, rf.predict(X_test))print ("随机森林 AUC = %2.2f" % rf_roc_auc)print(classification_report(y_test, rf.predict(X_test)))</code></pre><pre><code>随机森林 AUC = 0.97              precision    recall  f1-score   support           0       0.98      0.99      0.99      1714           1       0.97      0.94      0.96       536    accuracy                           0.98      2250   macro avg       0.98      0.97      0.97      2250weighted avg       0.98      0.98      0.98      2250</code></pre><h4 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h4><pre><code># ROC 图from sklearn.metrics import roc_curve# 计算ROC曲线rf_fpr, rf_tpr, rf_thresholds = roc_curve(y_test, rf.predict_proba(X_test)[:,1])dt_fpr, dt_tpr, dt_thresholds = roc_curve(y_test, dtree.predict_proba(X_test)[:,1])plt.figure()# 随机森林 ROCplt.plot(rf_fpr, rf_tpr, label='Random Forest (area = %0.2f)' % rf_roc_auc)# 决策树 ROCplt.plot(dt_fpr, dt_tpr, label='Decision Tree (area = %0.2f)' % dt_roc_auc)# 绘图plt.xlim([0.0, 1.0])plt.ylim([0.0, 1.05])plt.xlabel('False Positive Rate')plt.ylabel('True Positive Rate')plt.title('ROC Graph')plt.legend(loc="lower right")plt.show()</code></pre><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cml2%5C1.png" alt="1"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cnn手写数字识别</title>
      <link href="/2020/05/13/ml1/"/>
      <url>/2020/05/13/ml1/</url>
      
        <content type="html"><![CDATA[<pre><code>import tensorflow as tfimport numpy as npimport randomfrom tensorflow.examples.tutorials.mnist import input_data</code></pre><pre><code>mnist =  input_data.read_data_sets('MNIST_data',one_hot=True)imageIuput = tf.placeholder(tf.float32,[None,784])lableIuput = tf.placeholder(tf.float32,[None,10])#数据维度调整imageInputReshape = tf.reshape(imageIuput,[-1,28,28,1])#卷积w0 = tf.Variable(tf.truncated_normal([5,5,1,32],stddev=0.1))b0 = tf.Variable(tf.constant(0.1,shape=[32]))layer1 = tf.nn.relu(tf.nn.conv2d(imageInputReshape,w0,strides=[1,1,1,1],padding='SAME')+b0)layer1_pool = tf.nn.max_pool(layer1,ksize=[1,4,4,1],strides=[1,4,4,1],padding='SAME')w1 = tf.Variable(tf.truncated_normal([7*7*32,1024],stddev=0.1))b1 = tf.Variable(tf.constant(0.1,shape=[1024]))h_resshape = tf.reshape(layer1_pool,[-1,7*7*32])h1 = tf.nn.relu(tf.matmul(h_reshpe,w1)+b1)W2 = tf.Variable(tf.truncated_normal([1024,10],stddev=0.1))b2 = tf.Variable(tf.constant(0.1,shape=[10]))pred = tf.nn.softmax(tf.matmul(h1,w2)+b2)loss = lableIuput*tf.log(pred)loss1 = 0for i in range(0,100):    for j in range(0,10):        loss1 = loss1 - loss[i.j]loss3 = loss1/100train = tf.train.GradientDescentOptimizer(0.01).minimize(loss)with tf.Session() as sess:    sess.run(tf.global_variables_initializer())    for i in range(100):        images,labels = mnist.train.next_batch(500)        sess.run(train,feed_dict = {imageIuput:images,lableIuput:labels})        pred_test = sess.run(pred,feed_dict={imageIuput:images,lableIuput:labels})        acc = tf.equal(tf.arg_max(pred_test,1),tf.arg_max(mnist.test.labels))        acc_floaat = tf.reduce_mean(tf.cast(acc,tf.float32))        acc_result = sess.run(acc_floaat,feed_dict={imageIuput:mnist.test.images,lableIuput:mnist.test.labels})        print(acc_floaat)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> dl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigData大数据</title>
      <link href="/2020/05/13/bigdata1/"/>
      <url>/2020/05/13/bigdata1/</url>
      
        <content type="html"><![CDATA[<p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C1.png" alt="1"></p><p><strong>Volume：数据量大</strong></p><p><strong>Variety：类型繁多，关联性多</strong></p><p><strong>Velocity：速度快</strong></p><p><strong>Value：    价值密度低</strong></p><h2 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a><strong>安装Hadoop</strong></h2><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C2.png" alt="2"></p><h4 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h4><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C3.png" alt="3"></p><h4 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h4><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C4.png" alt="4"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C5.png" alt="5"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C6.png" alt="6"></p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a><strong>Hadoop</strong></h2><p><strong>分布式存储 + 分布式计算平台</strong></p><p><img src="C:%5CUsers%5CMachen%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1583929316491.png" alt="1583929316491"></p><p>开源的，可靠地分布式存储技术，可扩展的</p><p>Hadop Commen</p><p>HDFS:分布式文件系统，提高存储量</p><p>Yarn:资源调度</p><p>MapReduce：计算框架</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p><strong>1，高可靠性</strong></p><p>​            数据块多副本</p><p>​            重新调度计算</p><p><strong>2，高扩展性</strong></p><p>​            存储/计算资源不够时，可以横向的线性扩展机器</p><p>​            一个集群中包含数以千计的节点</p><p><strong>3，其他</strong></p><p>​            存储在廉价机器上，降低成本</p><p>​            成熟的生态圈</p><h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a><strong>HDFS</strong></h3><p><strong>Hadoop Distributed File System</strong></p><p><strong>特点：可扩展性，容错性，海量存储</strong></p><p><strong>将文件切分成指定大小的数据块并以多副本存储在多个机器上</strong></p><p><strong>设计目标：</strong></p><p>​        非常巨大的分布式文件系统</p><p>​        运行在普通廉价的硬件上</p><p>​        以扩展，为用户提高存储服务</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h4><p>​        1，Master(NameNode/NN)  带N个Slaves(DataNode/DN)</p><p>​            HDFS/YARN/HBASE</p><p>​            2，一个文件会被拆分成多个block</p><h6 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode:"></a>NameNode:</h6><p>​        负责客户端请求的响应</p><p>​        负责元数据（文件的名称，副本系数，Block存放的DN)的管理</p><h6 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode:"></a>DataNode:</h6><p>​        存储用户的文件对应的数据块（Block)</p><p>​        要定期向NN发送心跳信息，汇报本身及其所有的Block信息，健康状况</p><p>A typical deployment has a dedicated machine that runs only the NameNode software.</p><p>一台机器上运行一台NameNode</p><p>Each of the other machines in the cluster runs one instance of the DataNode software. The architecture does not preclude running multiple DataNodes on the same machine but in a real deployment that is rarely the case.</p><p>集群中的每台其他计算机都运行DataNode软件的一个实例，该架构你并不排除在一台机器上运行多个DataNode,而在世纪部署中很少出现这种情况 </p><p>HDFS中的文件只能写入一次（追加和截断除外），并且在任何时候都只能具有一个写入器。        </p><p><strong>NameNode + N个DataNode</strong></p><p><strong>nnhe dn是部署在不同的节点上</strong></p><p>支持层级目录</p><p>文件中除最后一个块外的所有块都具有相同的大小，而在添加了对可变长度块的支持后，用户可以在不填充最后一个块的情况下开始新的块，而不用配置的块大小。</p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C7.png" alt="7"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C8.png" alt="8"></p><h4 id="HDFS上传文件的流程"><a href="#HDFS上传文件的流程" class="headerlink" title="HDFS上传文件的流程"></a>HDFS上传文件的流程</h4><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C9.png" alt="9"></p><h2 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h2><p><strong>负责整个集群资源的管理和调度</strong></p><p><strong>特点：扩展性，容错性，多框架资源统一调度</strong></p><p><strong>MapReduce：Master/Slave 架构。1个JobTracker带多个TaskTracker</strong></p><p><strong>JobTracker：负责资源管理和作业调度</strong></p><p><strong>TaskTracker：</strong></p><p>​        <strong>定期向JT汇报本节点的健康状况，资源使用情况，作业执行情况</strong></p><p>​        <strong>接收来自JT的名：启动任务/杀死任务</strong></p><p><strong>YARN：不同计算框架可以共享同一个HDFS集群上的数据，享受整体的资源调度</strong></p><h4 id="YARN架"><a href="#YARN架" class="headerlink" title="YARN架"></a>YARN架</h4><h4 id="1，ResourceManager：RM"><a href="#1，ResourceManager：RM" class="headerlink" title="1，ResourceManager：RM"></a><em>1，ResourceManager：RM</em></h4><p>​                整个集群同一时间提供服务的RM只有一个，负责集群资源的同意管理和调度</p><p>·                处理客户端的请求：提交一个作业，杀死一个作业</p><p>​                监控NM,一旦某个NM挂了，那么该NM上运行的任务需要告诉我们的AM如            何处理</p><p>​            <strong>2,NodeManager：NM</strong></p><p>​                整个集群中有多个，负责自己本身节点资源灌流和使用</p><p>​                定时向RM汇报本节点的资源使用情况</p><p>​                接收并处理来自RM的各种命令：启动Container</p><p>​                处理来自AM的命令</p><p>​                单个节点的资源管理</p><p>​            <strong>3，ApplicationMaster：AM</strong></p><p>​                每个应用程序对应一个：MR,Spark,负责应用程序的管理</p><p>​                为应用程序向RM申请资源，（core,memory),分配给内部task</p><p>​                需要与NM通信，启动/停止task, task是运行在container里面，AM也是运行在container</p><p>​            <strong>4，Container</strong></p><p>​                封装了CPU,Memory等资源的一个容器</p><p>​                是一个任务运行环境的抽象</p><p>​            <strong>5，Client</strong></p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a><strong>MapReduce</strong></h2><p><strong>分布式计算框架</strong></p><p><strong>特点：扩展性，容错性，海量数据离线处理</strong></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5CBigData1%5C10.png" alt="10"></p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念*"></a><strong><em>核心概念*</em></strong></h4><p><strong>Split：交由MapReduce作业来处理的数据块，是MapReduce中最小的计算单元</strong></p><p>​        <strong>HDFS：blocksize 是HDFS中最小的存储单元  128M</strong></p><p>​        <strong>默认情况下：他们是意义对应的</strong></p><p><strong>InputFormat：将我们输入的数据进行分片</strong></p><p><strong>OutputFormat</strong></p><p><strong>Combiner</strong></p><p><strong>Partitioner</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> BigData </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BidData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习入门</title>
      <link href="/2020/05/13/dl2/"/>
      <url>/2020/05/13/dl2/</url>
      
        <content type="html"><![CDATA[<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><pre><code>tf.get_default_graph()op,sess或者tensor的graph属性</code></pre><h3 id="会话-类"><a href="#会话-类" class="headerlink" title="会话(类)"></a>会话(类)</h3><p>1：运行图的结构</p><p>2：分配资源计算</p><p>3：掌握资源（变量的生命周期，队列，线程）</p><p>tf.Session()一次只能运行一个图</p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C1.png" alt="1"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C2.png" alt="2"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C3.png" alt="3"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C4.png" alt="4"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C5.png" alt="5"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdl2%5C6.png" alt="6"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习和机器学习的区别</title>
      <link href="/2020/05/13/dl1/"/>
      <url>/2020/05/13/dl1/</url>
      
        <content type="html"><![CDATA[<h3 id="深度学习和机器学习的区别"><a href="#深度学习和机器学习的区别" class="headerlink" title="深度学习和机器学习的区别"></a>深度学习和机器学习的区别</h3><p>机器学习                                                                    神经网络</p><p>算法：  分类：神经网络（简单）                         神经网络（深度）</p><p>​                                回归                                            图像：卷积神经网络</p><p>​                                                                                    自然语言处理：循环神经网络</p><p>tensor: 张量</p><p>operation:节点</p><p>grape:图：整个程序的结构</p><p>会话：运算程序的图</p><p>计算密集型                                                        IO密集型</p><p>​                                                                                            </p><p>框架    tensorflow                                                 django，scrapy</p><p>​                                                                                    网页请求</p><p>tensorflow：前端系统：定义程序的图的机构</p><p>​                        后端系统：运算图结构</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
            <tag> dl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狗语言入门</title>
      <link href="/2020/05/13/go1/"/>
      <url>/2020/05/13/go1/</url>
      
        <content type="html"><![CDATA[<h3 id="语言优势："><a href="#语言优势：" class="headerlink" title="语言优势："></a><strong>语言优势：</strong></h3><p>1，可直接编译成机器码，不依赖其他库，部署就是人一个文件</p><p>2，静态类型语言</p><p>3，语言层面支持并发</p><p>4，丰富的库</p><p>5，跨平台编译</p><p>6，内嵌C支持</p><h3 id="适合做什么？"><a href="#适合做什么？" class="headerlink" title="适合做什么？"></a><strong>适合做什么？</strong></h3><p>1，服务器日志</p><p>2，分布式系统</p><p>3，网络编程</p><p>4，内存数据库</p><p>5，云平台</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h2><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C1.png" alt="1"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C2.png" alt="2"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C3.png" alt="3"></p><h4 id="狗语言没有继承和多态，是通过接口完成的"><a href="#狗语言没有继承和多态，是通过接口完成的" class="headerlink" title="狗语言没有继承和多态，是通过接口完成的*"></a><em>狗语言没有继承和多态，是通过接口完成的*</em></h4><h2 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包*"></a><strong>函数与闭包*</strong></h2><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C4.png" alt="4"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C5.png" alt="5"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C6.png" alt="6"></p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cgo1%5C7.png" alt="7"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2020/05/13/linux1/"/>
      <url>/2020/05/13/linux1/</url>
      
        <content type="html"><![CDATA[<p>很多企业都是要求会linux和unix系统，很多开发都在unix系统上进行开发，所有掌握linux命令是必不可少的，建议可以尝试在linux上进行开发，用着用着肯定就记住了，虽说很多运维都记不住全部命令是百度的，但你是要笔试的，不可能查常用命令还是要会的。本文介绍一些linux命令。</p><h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a><strong>系统信息</strong></h4><p>arch 显示机器的处理器架构<br>uname -m 显示机器的处理器架构<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS </p><h4 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a><strong>关机 (系统的关机、重启以及登出 )</strong></h4><p>shutdown -h now 关闭系统<br>init 0 关闭系统<br>telinit 0 关闭系统<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启<br>reboot 重启<br>logout 注销 </p><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a><strong>文件和目录</strong></h4><p>cd /home 进入 ‘/ home’ 目录’<br>cd .. 返回上一级目录<br>cd ../.. 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构<br>lstree 显示文件和目录由根目录开始的树形结构<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录 </p><p>cp -r dir1 dir2 复制一个目录及子目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) </p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a><strong>文件搜索</strong></h4><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径 </p><h4 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a><strong>挂载一个文件系统</strong></h4><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 </p><h4 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a><strong>磁盘空间</strong></h4><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </p><h4 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a><strong>用户和群组</strong></h4><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 </p><h4 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h4><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位 </p><h4 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a><strong>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</strong></h4><p>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性 </p><h4 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a><strong>打包和压缩文件</strong></h4><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包 </p><h4 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a><strong>RPM 包 - （Fedora, Redhat及类似系统）</strong></h4><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas</title>
      <link href="/2020/05/13/pandas/"/>
      <url>/2020/05/13/pandas/</url>
      
        <content type="html"><![CDATA[<p>pandas和numpy为机器学习和深度学习必不可少的两个库，最基础的两个库，是经常用到的两个库，所以非常重要。</p><h4 id="一、常用功能及函数简介"><a href="#一、常用功能及函数简介" class="headerlink" title="一、常用功能及函数简介"></a><strong>一、常用功能及函数简介</strong></h4><h5 id="包导入"><a href="#包导入" class="headerlink" title="包导入"></a><strong>包导入</strong></h5><p>一般我们需要做如下导入，numpy和pandas一般需要联合使用：</p><pre><code>import pandas as pdimport numpy as np</code></pre><p>本文采用如下缩写：</p><pre><code>df：Pandas DataFrame对象s：  Pandas Series对象</code></pre><h5 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a><strong>数据导入</strong></h5><p>pd.read_csv(filename)：从CSV文件导入数据<br>pd.read_table(filename)：从限定分隔符的文本文件导入数据<br>pd.read_excel(filename)：从Excel文件导入数据<br>pd.read_sql(query, connection_object)：从SQL表/库导入数据<br>pd.read_json(json_string)：从JSON格式的字符串导入数据<br>pd.read_html(url)：解析URL、字符串或者HTML文件<br>pd.read_clipboard()：从粘贴板获取内容<br>pd.DataFrame(dict)：从字典对象导入数据</p><h5 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a><strong>数据导出</strong></h5><p>df.to_csv(filename)：导出数据到CSV文件<br>df.to_excel(filename)：导出数据到Excel文件<br>df.to_sql(table_name, connection_object)：导出数据到SQL表<br>df.to_json(filename)：以Json格式导出数据到文本文件</p><h5 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h5><p>pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象<br>pd.Series(my_list)：从可迭代对象my_list创建一个Series对象<br>df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引</p><p>index和<strong>reindex</strong>联合使用很有用处，index可作为索引并且元素乱排序之后，所以跟着元素保持不变，因此，当重拍元素时，只需要对index进行才重排即可:reindex。</p><p>另外， reindex时，还可以增加新的标为NaN的元素。</p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cpandas%5C1.png" alt="1"></p><h5 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a><strong>数据查看</strong></h5><p>df.head(n)：查看DataFrame对象的前n行<br>df.tail(n)：查看DataFrame对象的最后n行<br>df.shape()：查看行数和列数<br>df.info()：查看索引、数据类型和内存信息<br>df.describe()：查看数值型列的汇总统计<br>s.value_counts(dropna=False)：查看Series对象的唯一值和计数<br>df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</p><p>apply的用处很多，比如可以通过跟<strong>lambda函数</strong>联合，完成很多功能：将包含某个部分的元素挑出来等等。</p><ol><li>cities[‘Is wide and has saint name’] = (cities[‘Area square miles’] &gt; 50) &amp; cities[‘City name’].apply(lambda name: name.startswith(‘San’))</li></ol><h5 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a><strong>数据选取</strong></h5><ul><li>df[col]：根据列名，并以Series的形式返回列</li><li>df[[col1, col2]]：以DataFrame形式返回多列</li><li>s.iloc[0]：按位置选取数据</li><li>s.loc[‘index_one’]：按索引选取数据</li><li>df.iloc[0,:]：返回第一行</li></ul><h5 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a><strong>数据清洗</strong></h5><p>df.columns = [‘a’,’b’,’c’]：重命名列名<br>pd.isnull()：检查DataFrame对象中的空值，并返回一个Boolean数组<br>pd.notnull()：检查DataFrame对象中的非空值，并返回一个Boolean数组<br>df.dropna()：删除所有包含空值的行<br>df.fillna(x)：用x替换DataFrame对象中所有的空值<br>s.astype(float)：将Series中的数据类型更改为float类型<br>s.replace(1,’one’)：用‘one’代替所有等于1的值<br>df.rename(columns=lambda x: x + 1)：批量更改列名<br>df.set_index(‘column_one’)：更改索引列</p><h5 id="数据处理：Filter-Sort-GroupBy"><a href="#数据处理：Filter-Sort-GroupBy" class="headerlink" title="数据处理：Filter, Sort, GroupBy"></a><strong>数据处理：Filter, Sort, GroupBy</strong></h5><p>df[df[col] &gt; 0.5]：选择col列的值大于0.5的行<br>df.sort_values(col1)：按照列col1排序数据，默认升序排列<br>df.groupby(col)：返回一个按列col进行分组的Groupby对象<br>df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值<br>df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表<br>data.apply(np.mean)：对DataFrame中的每一列应用函数np.mean</p><h5 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a><strong>数据合并</strong></h5><ul><li>df1.append(df2)：将df2中的行添加到df1的尾部</li><li>df.concat([df1, df2],axis=1)：将df2中的列添加到df1的尾部</li><li>df1.join(df2,on=col1,how=’inner’)：对df1的列和df2的列执行SQL形式的join</li></ul><h5 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a><strong>数据统计</strong></h5><p>df.describe()：查看数据值列的汇总统计<br>df.mean()：返回所有列的均值<br>df.corr()：返回列与列之间的相关系数<br>df.count()：返回每一列中的非空值的个数<br>df.max()：返回每一列的最大值<br>df.min()：返回每一列的最小值<br>df.median()：返回每一列的中位数<br>df.std()：返回每一列的标准差</p><h5 id="Pandas支持的数据类型"><a href="#Pandas支持的数据类型" class="headerlink" title="Pandas支持的数据类型"></a><strong>Pandas支持的数据类型</strong></h5><ul><li>int 整型</li><li>float 浮点型</li><li>bool 布尔类型</li><li>object 字符串类型</li><li>category 种类</li><li>datetime 时间类型</li></ul><h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a><strong>补充：</strong></h5><ul><li>df.astypes: 数据格式转换</li><li>df.value_counts:相同数值的个数统计</li><li>df.hist(): 画直方图</li><li>df.get_dummies: one-hot编码，将类型格式的属性转换成矩阵型的属性。比如：三种颜色RGB，红色编码为[1 0 0]</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的切片</title>
      <link href="/2020/05/13/slice/"/>
      <url>/2020/05/13/slice/</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><p>利用python解决问题的过程中，经常会遇到从某个对象中抽取部分值的情况。“切片”操作正是专门用于实现这一目标的有力武器。理论上，只要条件表达式得当，可以通过单次或多次切片操作实现任意目标值切取。切片操作的基本语法比较简单，但如果不彻底搞清楚内在逻辑，也极容易产生错误，而且这种错误有时隐蔽得较深，难以察觉。本文通过详细例子总结归纳了切片操作的各种情形，下文均以list类型作为实验对象，其结论可推广至其他可切片对象。</p><h4 id="一、-Python可切片对象的索引方式"><a href="#一、-Python可切片对象的索引方式" class="headerlink" title="一、 Python可切片对象的索引方式"></a>一、 Python可切片对象的索引方式</h4><p>包括：正索引和负索引两部分，如下图所示，以list对象a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]为例：</p><p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cslice%5C1.png" alt="1"></p><h4 id="二、-Python切片操作的一般方式"><a href="#二、-Python切片操作的一般方式" class="headerlink" title="二、 Python切片操作的一般方式"></a>二、 Python切片操作的一般方式</h4><p>一个完整的切片表达式包含两个“:”，用于分隔三个参数(start_index、end_index、step)。当只有一个“:”时，默认第三个参数step=1；当一个“:”也没有时，start_index=end_index，表示切取start_index指定的那个元素。</p><pre><code>切片操作基本表达式：object[start_index:end_index:step]</code></pre><p>step：正负数均可，其绝对值大小决定了切取数据时的‘‘步长”，而正负号决定了“切取方向”，正表示“从左往右”取值，负表示“从右往左”取值。当step省略时，默认为1，即从左往右以步长1取值。“切取方向非常重要！”“切取方向非常重要！”“切取方向非常重要！”，重要的事情说三遍！</p><p>start_index：表示起始索引（包含该索引对应值）；该参数省略时，表示从对象“端点”开始取值，至于是从“起点”还是从“终点”开始，则由step参数的正负决定，step为正从“起点”开始，为负从“终点”开始。</p><p>end_index：表示终止索引（不包含该索引对应值）；该参数省略时，表示一直取到数据“端点”，至于是到“起点”还是到“终点”，同样由step参数的正负决定，step为正时直到“终点”，为负时直到“起点”。</p><h4 id="三、-Python切片操作详细例子"><a href="#三、-Python切片操作详细例子" class="headerlink" title="三、 Python切片操作详细例子"></a>三、 Python切片操作详细例子</h4><p>以下示例均以list对象a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]为例：</p><pre><code>&gt;&gt;&gt;a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h5 id="1-切取单个元素"><a href="#1-切取单个元素" class="headerlink" title="1. 切取单个元素"></a>1. 切取单个元素</h5><pre><code>&gt;&gt;&gt;a[0]&gt;&gt;&gt;0&gt;&gt;&gt;a[-4]&gt;&gt;&gt;6当索引只有一个数时，表示切取某一个元素。</code></pre><h5 id="2-切取完整对象"><a href="#2-切取完整对象" class="headerlink" title="2. 切取完整对象"></a>2. 切取完整对象</h5><pre><code>&gt;&gt;&gt;a[:] #从左往右&gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;a[::]#从左往右&gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;a[::-1]#从右往左&gt;&gt;&gt; [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</code></pre><h5 id="3-start-index和end-index全为正（-）索引的情况"><a href="#3-start-index和end-index全为正（-）索引的情况" class="headerlink" title="3. start_index和end_index全为正（+）索引的情况"></a>3. start_index和end_index全为正（+）索引的情况</h5><pre><code>&gt;&gt;&gt;a[1:6]&gt;&gt;&gt; [1, 2, 3, 4, 5]step=1，从左往右取值，start_index=1到end_index=6同样表示从左往右取值。</code></pre><pre><code>&gt;&gt;&gt;a[1:6:-1]&gt;&gt;&gt; []输出为空列表，说明没取到数据。step=-1，决定了从右往左取值，而start_index=1到end_index=6决定了从左往右取值，两者矛盾，所以为空。</code></pre><pre><code>&gt;&gt;&gt;a[6:2]&gt;&gt;&gt; []同样输出为空列表。step=1，决定了从左往右取值，而start_index=6到end_index=2决定了从右往左取值，两者矛盾，所以为空。</code></pre><pre><code>&gt;&gt;&gt;a[:6]&gt;&gt;&gt; [0, 1, 2, 3, 4, 5]step=1，表示从左往右取值，而start_index省略时，表示从端点开始，因此这里的端点是“起点”，即从“起点”值0开始一直取到end_index=6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[:6:-1]&gt;&gt;&gt; [9, 8, 7]step=-1，从右往左取值，而start_index省略时，表示从端点开始，因此这里的端点是“终点”，即从“终点”值9开始一直取到end_index=6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[6:]&gt;&gt;&gt; [6, 7, 8, 9]step=1，从左往右取值，从start_index=6开始，一直取到“终点”值9。</code></pre><pre><code>&gt;&gt;&gt;a[6::-1]&gt;&gt;&gt; [6, 5, 4, 3, 2, 1, 0]step=-1，从右往左取值，从start_index=6开始，一直取到“起点”0。</code></pre><h5 id="4-start-index和end-index全为负（-）索引的情况"><a href="#4-start-index和end-index全为负（-）索引的情况" class="headerlink" title="4. start_index和end_index全为负（-）索引的情况"></a>4. start_index和end_index全为负（-）索引的情况</h5><pre><code>&gt;&gt;&gt;a[-1:-6]&gt;&gt;&gt; []step=1，从左往右取值，而start_index=-1到end_index=-6决定了从右往左取值，两者矛盾，所以为空。索引-1在-6的右边（如上图）</code></pre><pre><code>&gt;&gt;&gt;a[-1:-6:-1]&gt;&gt;&gt; [9, 8, 7, 6, 5]step=-1，从右往左取值，start_index=-1到end_index=-6同样是从右往左取值。索引-1在6的右边（如上图）</code></pre><pre><code>&gt;&gt;&gt;a[-6:-1]&gt;&gt;&gt; [4, 5, 6, 7, 8]step=1，从左往右取值，而start_index=-6到end_index=-1同样是从左往右取值。索引-6在-1的左边（如上图）</code></pre><pre><code>&gt;&gt;&gt;a[:-6]&gt;&gt;&gt; [0, 1, 2, 3]step=1，从左往右取值，从“起点”开始一直取到end_index=-6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[:-6:-1]&gt;&gt;&gt; [9, 8, 7, 6, 5]step=-1，从右往左取值，从“终点”开始一直取到end_index=-6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[-6:]&gt;&gt;&gt; [4, 5, 6, 7, 8, 9]step=1，从左往右取值，从start_index=-6开始，一直取到“终点”。</code></pre><pre><code>&gt;&gt;&gt;a[-6::-1]&gt;&gt;&gt; [4, 3, 2, 1, 0]step=-1，从右往左取值，从start_index=-6开始，一直取到“起点”。</code></pre><pre><code>&gt;&gt;&gt;a[:-6]&gt;&gt;&gt; [0, 1, 2, 3]step=1，从左往右取值，从“起点”开始一直取到end_index=-6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[:-6:-1]&gt;&gt;&gt; [9, 8, 7, 6, 5]step=-1，从右往左取值，从“终点”开始一直取到end_index=-6（该点不包括）。</code></pre><pre><code>&gt;&gt;&gt;a[-6:]&gt;&gt;&gt; [4, 5, 6, 7, 8, 9]step=1，从左往右取值，从start_index=-6开始，一直取到“终点”。</code></pre><pre><code>&gt;&gt;&gt;a[-6::-1]&gt;&gt;&gt; [4, 3, 2, 1, 0]step=-1，从右往左取值，从start_index=-6开始，一直取到“起点”。</code></pre><pre><code>5. start_index和end_index正（+）负（-）混合索引的情况</code></pre><pre><code>&gt;&gt;&gt;a[1:-6]&gt;&gt;&gt; [1, 2, 3]start_index=1在end_index=-6的左边，因此从左往右取值，而step=1同样决定了从左往右取值，因此结果正确</code></pre><pre><code>&gt;&gt;&gt;a[1:-6:-1]&gt;&gt;&gt; []start_index=1在end_index=-6的左边，因此从左往右取值，但step=-则决定了从右往左取值，两者矛盾，因此为空。</code></pre><pre><code>&gt;&gt;&gt;a[-1:6]&gt;&gt;&gt; []start_index=-1在end_index=6的右边，因此从右往左取值，但step=1则决定了从左往右取值，两者矛盾，因此为空。</code></pre><pre><code>&gt;&gt;&gt;a[-1:6:-1]&gt;&gt;&gt; [9, 8, 7]start_index=-1在end_index=6的右边，因此从右往左取值，而step=-1同样决定了从右往左取值，因此结果正确。</code></pre><h5 id="6-多层切片操作"><a href="#6-多层切片操作" class="headerlink" title="6. 多层切片操作"></a>6. 多层切片操作</h5><pre><code>&gt;&gt;&gt;a[:8][2:5][-1:]&gt;&gt;&gt; [4]相当于：a[:8]=[0, 1, 2, 3, 4, 5, 6, 7]a[:8][2:5]= [2, 3, 4]a[:8][2:5][-1:] = [4]理论上可无限次多层切片操作，只要上一次返回的是非空可切片对象即可。</code></pre><h5 id="7-切片操作的三个参数可以用表达式"><a href="#7-切片操作的三个参数可以用表达式" class="headerlink" title="7. 切片操作的三个参数可以用表达式"></a>7. 切片操作的三个参数可以用表达式</h5><pre><code>&gt;&gt;&gt;a[2+1:3*2:7%3]&gt;&gt;&gt; [3, 4, 5]即：a[2+1:3*2:7%3] = a[3:6:1]</code></pre><h5 id="8-其他对象的切片操作"><a href="#8-其他对象的切片操作" class="headerlink" title="8. 其他对象的切片操作"></a>8. 其他对象的切片操作</h5><p>前面的切片操作以list对象为例进行说明，但实际上可进行切片操作的数据类型还有很多，包括元组、字符串等等。</p><pre><code>&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]&gt;&gt;&gt; (0, 1, 2)元组的切片操作</code></pre><pre><code>&gt;&gt;&gt;'ABCDEFG'[::2]&gt;&gt;&gt;'ACEG'字符串的切片操作</code></pre><pre><code>&gt;&gt;&gt;for i in range(1,100)[2::3][-5:]:        print(i)&gt;&gt;&gt;8790939699就是利用range()函数生成1-99的整数，然后从start_index=2（即3）开始以step=3取值，直到终点，再在新序列中取最后五个数。</code></pre><h4 id="四、-常用切片操作"><a href="#四、-常用切片操作" class="headerlink" title="四、 常用切片操作"></a>四、 常用切片操作</h4><h5 id="1-取偶数位置"><a href="#1-取偶数位置" class="headerlink" title="1.取偶数位置"></a>1.取偶数位置</h5><pre><code>&gt;&gt;&gt;b = a[::2][0, 2, 4, 6, 8]</code></pre><h5 id="2-取奇数位置"><a href="#2-取奇数位置" class="headerlink" title="2.取奇数位置"></a>2.取奇数位置</h5><pre><code>&gt;&gt;&gt;b = a[1::2][1, 3, 5, 7, 9]</code></pre><h5 id="3-拷贝整个对象"><a href="#3-拷贝整个对象" class="headerlink" title="3.拷贝整个对象"></a>3.拷贝整个对象</h5><pre><code>&gt;&gt;&gt;b = a[:] #&gt;&gt;&gt;print(b) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;print(id(a)) #41946376&gt;&gt;&gt;print(id(b)) #41921864或&gt;&gt;&gt;b = a.copy()&gt;&gt;&gt;print(b) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;print(id(a)) #39783752&gt;&gt;&gt;print(id(b)) #39759176</code></pre><p>需要注意的是：<strong>[:]和.copy()都属于“浅拷贝”，只拷贝最外层元素，内层嵌套元素则通过引用方式共享，而非独立分配内存</strong>，如果需要彻底拷贝则需采用“深拷贝”方式，如下例所示：</p><pre><code>&gt;&gt;&gt;a = [1,2,['A','B']]&gt;&gt;&gt;print('a={}'.format(a))&gt;&gt;&gt;b = a[:]&gt;&gt;&gt;b[0] = 9 #修改b的最外层元素，将1变成9&gt;&gt;&gt;b[2][0] = 'D' #修改b的内嵌层元素&gt;&gt;&gt;print('a={}'.format(a))&gt;&gt;&gt;print('b={}'.format(b))&gt;&gt;&gt;print('id(a)={}'.format(id(a)))&gt;&gt;&gt;print('id(b)={}'.format(id(b)))a=[1, 2, ['A', 'B']] #原始aa=[1, 2, ['D', 'B']] #b修改内部元素A为D后，a中的A也变成了D，说明共享内部嵌套元素，但外部元素1没变。b=[9, 2, ['D', 'B']] #修改后的bid(a)=38669128id(b)=38669192</code></pre><h5 id="4-修改单个元素"><a href="#4-修改单个元素" class="headerlink" title="4.修改单个元素"></a>4.修改单个元素</h5><pre><code>&gt;&gt;&gt;a[3] = ['A','B'][0, 1, 2, ['A', 'B'], 4, 5, 6, 7, 8, 9]</code></pre><h5 id="5-在某个位置插入元素"><a href="#5-在某个位置插入元素" class="headerlink" title="5.在某个位置插入元素"></a>5.在某个位置插入元素</h5><pre><code>&gt;&gt;&gt;a[3:3] = ['A','B','C'][0, 1, 2, 'A', 'B', 'C', 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt;a[0:0] = ['A','B']['A', 'B', 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><h5 id="6-替换一部分元素"><a href="#6-替换一部分元素" class="headerlink" title="6.替换一部分元素"></a>6.替换一部分元素</h5><pre><code>&gt;&gt;&gt;a[3:6] = ['A','B'][0, 1, 2, 'A', 'B', 6, 7, 8, 9]</code></pre><h4 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h4><p>（一）start_index、end_index、step三者可同为正、同为负，或正负混合。但必须遵循一个原则，即：当start_index表示的实际位置在end_index的左边时，从左往右取值，此时step必须是正数（同样表示从左往右）；当start_index表示的实际位置在end_index的右边时，表示从右往左取值，此时step必须是负数（同样表示从右往左），即两者的取值顺序必须相同。</p><p>（二）当start_index或end_index省略时，取值的起始索引和终止索引由step的正负来决定，这种情况不会有取值方向矛盾（即不会返回空列表[]），但正和负取到的结果顺序是相反的，因为一个向左一个向右。</p><p>（三）step的正负是必须要考虑的，尤其是当step省略时。比如a[-1:]，很容易就误认为是从“终点”开始一直取到“起点”，即a[-1:]= [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]，但实际上a[-1:]=[9]（注意不是9），原因在于step省略时step=1表示从左往右取值，而起始索引start_index=-1本身就是对象的最右边元素了，再往右已经没数据了，因此结果只含有9一个元素。</p><p>（四）需要注意：“取单个元素（不带“:”）”时，返回的是对象的某个元素，其类型由元素本身的类型决定，而与母对象无关，如上面的a[0]=0、a[-4]=6，元素0和6都是“数值型”，而母对象a却是“list”型；“取连续切片（带“:”）”时，返回结果的类型与母对象相同，哪怕切取的连续切片只包含一个元素，如上面的a[-1:]=[9]，返回的是一个只包含元素“9”的list，而非数值型“9‘。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>django错误</title>
      <link href="/2020/05/12/django1/"/>
      <url>/2020/05/12/django1/</url>
      
        <content type="html"><![CDATA[<p><img src="C:%5CUsers%5CMachen%5CDesktop%5Chexo%5Chexo-matery-modified-master%5Csource_posts%5Cdjango1%5C1.png" alt="1"></p><p>在数据迁移是遇到这个错误，解决方法是：因为应用都放在apps下，发生错误的原因是找不到对应的包，解决方法：apps文件夹右键找到Make Direcoory as 有个Resource，把apps文件夹都resource一下，目的使让pycharm找文件从apps目录下面找，这样导包就不会有问题，但是还有问题，这个仅仅在pycharm里面有用,在你用命令行运行manage.py时还会报错</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/12/leecode5/"/>
      <url>/2020/05/12/leecode5/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p> 回文串：从左边往右读和从右边往左读是一样的</p><pre><code>Iuput；s = 'abccccdd'Output：dccaccd</code></pre><h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><p>1：直接遍历数组统计每个字母出现的次数，根据奇数偶数</p><p>1，若字母出现的次数为2K次，则答案增加2K</p><p>2，若字母出现次数为2k+1,则答案增加2k</p><p>3，若存在字母出现为奇数，答案加一</p><pre><code>s = 'aasaddafdf'def fun(self,s):    hash1 = [0 for i in range(256)]  #记录字符出现的次数    for i in s:        hash1[ord[i]] += 1    ans = 0    odd = 0    # 有基数词的字符    for (char,num) in hash1.items():        if num &amp; 2 == 0:            ans += num        else:            ans += num - 1            odd = 1    ans += odd  #加上一个出现基数词的字符    return ansfun(s)</code></pre><hr><h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>用set保存出现了奇次数的字符</p><p>1，遍历数组</p><p>2，若一个字符在set中，将其从set删除</p><p>3，若不在，将其加入set</p><p>答案 = len(s) - len(set) - 1) (if len(set) &gt;0)</p><pre><code>def fun2(self,s):    hash2 = {}    for j in s:        if j in hash2:            del hash2[j]        else:            hash2[j] = True    remove = len(hash2)    if len(hash2) == 0:        return len(s)    else:        return len(s) - len(hash2) + 1</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题</title>
      <link href="/2020/05/12/leecode4/"/>
      <url>/2020/05/12/leecode4/</url>
      
        <content type="html"><![CDATA[<h4 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h4><p>给定两个相同大小的字符串A和B,再给一个字符串S,所有出现在S里的子串A[i]</p><p>都要替换成B[i].</p><pre><code>A = ['ab','aba','cba']B = ['cc','ccc','abd']s = 'ababa'Ans = 'cccba'</code></pre><h5 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h5><p>1，计算所有模式串的哈希值</p><p>2，计算需要替换字符串的s[0:i]的哈希值</p><p>3，遍历所有的模式串。看是否能替换</p><p>4，对于可替换的部分进行替换</p><p>5，对于字符串S的每个位置进行操作3和4</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre><code>def fun(a,b,s):    send = 31    mod = 10**9+7    targetHash = []  #A的哈希值    sourceHash = []   # = s[0,i]的哈希值    base = []  #bash[i] = 31** I    #求模式串的哈希值    for i in a:        temp = 0        for j in i:            temp = (temp * send + ord(j) - ord('a')) % mod        targetHash.append(temp)    temp = 0    sourceHash.append(temp)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leecode刷题</title>
      <link href="/2020/05/12/leecode1/"/>
      <url>/2020/05/12/leecode1/</url>
      
        <content type="html"><![CDATA[<h4 id="难度：简单"><a href="#难度：简单" class="headerlink" title="难度：简单"></a>难度：简单</h4><h5 id="题目要求："><a href="#题目要求：" class="headerlink" title="题目要求："></a>题目要求：</h5><p>​            Input: 1-&gt;2-&gt;3-&gt;null</p><p>​            Output: 3-&gt;2-&gt;1-&gt;null</p><h6 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h6><pre><code>class Solution:    def fun(self,head):        p,rev = head,None        while p:            rev,rev.next,p = p, rev, p.next        return rev</code></pre><h6 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h6><pre><code>def fun2(self,head):    pre = None    cur = head    while cur:        tmp = cur.next        cur.next = pre        pre = cur        cur = tmp    return pre</code></pre><hr><h6 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h6><p>递归</p><pre><code>class Solution:    def reverseList(self, head):        def help(head):            if head == None or head.next == None:                return head            pre,last = head(head.next)            last.next = head            head.next = None            return pre,head        rt,_ = help(head)        return rt</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法整理汇总（附代码）</title>
      <link href="/2020/02/16/sort-algorithms/"/>
      <url>/2020/02/16/sort-algorithms/</url>
      
        <content type="html"><![CDATA[<p>前言</p><p>本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。</p><p><strong>本文并不会详细讲解每种排序算法的原理</strong>，网上有很多很好的教程，大家可以自己去搜了看。</p><p>最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 <a href="https://leetcode-cn.com/problems/sort-an-array/" title="LeetCode 912. 排序数组" target="_blank" rel="noopener">LeetCode 912. 排序数组</a> 这道题。</p><h2 id="性质汇总"><a href="#性质汇总" class="headerlink" title="性质汇总"></a>性质汇总</h2><blockquote><p>如果发现表中有错误，请留言告知。</p></blockquote><table><thead><tr><th>算法</th><th>最好</th><th>最坏</th><th>平均</th><th>空间</th><th align="center">稳定性</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>选择排序</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>插入排序</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(1)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>快速排序</td><td>$O(n\log n)$</td><td>$O(n^2)$</td><td>$O(n\log n)$</td><td>$O(\log n)$~$O(n)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>归并排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n)$</td><td align="center">$\checkmark$</td><td align="center">$\checkmark$</td></tr><tr><td>希尔排序</td><td>$O(n^{1.3})$</td><td>$O(n^2)$</td><td>$O(n\log n)$~$O(n^2)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr><tr><td>计数排序</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>基数排序</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(nk)$</td><td>$O(n+k)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>桶排序</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n)$</td><td>$O(n+m)$</td><td align="center">$\checkmark$</td><td align="center">$\times$</td></tr><tr><td>堆排序</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(n\log n)$</td><td>$O(1)$</td><td align="center">$\times$</td><td align="center">$\checkmark$</td></tr></tbody></table><blockquote><p>如果表格显示有问题的话，还可以直接看下面的汇总图：</p></blockquote><p><img src="1.png" alt="十大经典排序算法性质汇总"></p><h3 id="维基百科"><a href="#维基百科" class="headerlink" title="维基百科"></a>维基百科</h3><p>我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。</p><p><strong>冒泡排序</strong><br><a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bubble_sort</a></p><p><strong>选择排序</strong><br><a href="https://en.wikipedia.org/wiki/Selection_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Selection_sort</a></p><p><strong>插入排序</strong><br><a href="https://en.wikipedia.org/wiki/Insertion_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Insertion_sort</a></p><p><strong>快速排序</strong><br><a href="https://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Quicksort</a></p><p><strong>归并排序</strong><br><a href="https://en.wikipedia.org/wiki/Merge_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Merge_sort</a></p><p><strong>希尔排序</strong><br><a href="https://en.wikipedia.org/wiki/Shellsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Shellsort</a></p><p><strong>计数排序</strong><br><a href="https://en.wikipedia.org/wiki/Counting_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Counting_sort</a></p><p><strong>基数排序</strong><br><a href="https://en.wikipedia.org/wiki/Radix_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Radix_sort</a></p><p><strong>桶排序</strong><br><a href="https://en.wikipedia.org/wiki/Bucket_sort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Bucket_sort</a></p><p><strong>堆排序</strong><br><a href="https://en.wikipedia.org/wiki/Heapsort" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heapsort</a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>所有的排序算法接口都是相同的，也就是 <code>vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums)</code> 。只需要你传入一个 <code>vector&lt;int&gt;</code> 类型的数组，就能返回排序后的结果。</p><p>运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sortArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 冒泡排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n<span class="token number">-2</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 选择排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    idx <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 插入排序（超时）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 快速排序（24 ms）</span>    <span class="token keyword">void</span> <span class="token function">qSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序（192 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span><span class="token punctuation">(</span>r<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> l<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> rnums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> rnums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token operator">-</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>lnums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token operator">-</span>m<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>rnums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nums <span class="token operator">=</span> <span class="token function">mSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 归并排序 + 非递归（80 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeSortNR</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> len <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> n<span class="token operator">-</span>len<span class="token punctuation">;</span> l <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> m <span class="token operator">=</span> l<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">2</span><span class="token operator">*</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> l<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token operator">-</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 希尔排序（40 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> gap <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">-</span>gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">-</span><span class="token operator">=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token operator">-</span>gap<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计数排序（32 ms）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">countSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> maxv<span class="token operator">-</span>minv<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token operator">+</span>minv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 基数排序（不适用于负数）</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxv <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxv <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxd<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">rank</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>maxd <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rank<span class="token punctuation">[</span><span class="token operator">--</span>count<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span>base<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            maxd<span class="token operator">--</span><span class="token punctuation">;</span>            base <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 桶排序 (20 ms)</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> minv <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">min_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> bs <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>maxv<span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">bucket</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>minv<span class="token punctuation">)</span><span class="token operator">/</span>bs<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sz <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nums<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆排序（32 ms）</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>p<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>c2<span class="token operator">&lt;</span>s <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>c2<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>c1<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> c2 <span class="token operator">:</span> c1<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
